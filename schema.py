#!/usr/bin/env python
# -*- coding: utf-8 -*-

from enum import IntEnum
from typing import ClassVar, Self, Iterator, NamedTuple
import re

from peewee import (TextField, IntegerField, BooleanField, ForeignKeyField, FloatField,
                    OperationalError, DoesNotExist)
from playhouse.sqlite_ext import JSONField

from database import BaseModel

DFLT_SEED_ROUNDS  = 8
DFLT_TOURN_ROUNDS = 8
DFLT_DIVISIONS    = 2

GAME_PTS          = 10

BRACKET_SEED      = 'seed'
BRACKET_TOURN     = 'rr'
BRACKET_PLAYOFF   = 'playoff'

# stage values are chronologically sequenced
TournStage = IntEnum('TournStage',
                     ['TOURN_CREATE',
                      'PLAYER_ROSTER',
                      'PLAYER_NUMS',
                      'SEED_BRACKET',
                      'SEED_RESULTS',
                      'SEED_TABULATE',
                      'SEED_RANKS',
                      'PARTNER_PICK',
                      'TOURN_TEAMS',
                      'TEAM_SEEDS',
                      'TOURN_BRACKET',
                      'TOURN_RESULTS',
                      'TOURN_TABULATE',
                      'TEAM_RANKS'])

class StageInfo(NamedTuple):
    """Behavior parameters and messages for tournament stages

    REVISIT(?): there is currently redundancy in the two boolean flags, but we may keep it
    this way for integrity checking
    """
    long_running: bool  # possible manual data entry/finalization in order to complete
    auto_advance: bool  # start next stage automatically upon completion
    start_msg:    str   # only needed if long_running
    compl_msg:    str   # not visible if auto_advance (though specified regardless)

# NOTE that we are being a little particular/pedantic about wording for messages here:
# - "seed" means assigned position within a bracket based on past performance
# - "seeding" means the seeding round process
# - "round robin" means the main tournament, not including playoffs
# - "playoffs" means the semi-final and final rounds of the tournament
# - "rank" or "ranking" means finish position after play is over
# - "position" means order on the scale of performance during play
# - "completed" means data entry of an activity (e.g. playing or picking) is done
# - "computed" or "tabulated" means something algorithmically generated by the program
# - "assigned" means the completion of a process that may be either manual or automated
#
STAGE_DATA = [
    StageInfo(False, False, None,                            "New tournament"),
    StageInfo(True,  True,  "Creating player roster",        "Player roster created"),
    StageInfo(True,  False, "Assigning player nums",         "Player nums assigned"),
    StageInfo(False, True,  "Generate seeding bracket",      "Seeding bracket created"),
    StageInfo(True , False, "Seeding round active",          "Seeding results completed"),
    StageInfo(False, False, "Tabulate seeding results",      "Seeding results tabulated"),
    StageInfo(False, True,  None,                            "Seeding rankings computed"),
    StageInfo(True,  False, "Picking partners",              "Partner picks completed"),
    StageInfo(False, False, "Generate round robin brackets", "Round robin teams created"),
    StageInfo(False, False, None,                            "Round robin team seeds computed"),
    StageInfo(False, True,  None,                            "Round robin brackets created"),
    StageInfo(True,  False, "Round robin play active",       "Round robin results completed"),
    StageInfo(False, False, "Tabulate round robin results",  "Round robin results tabulated"),
    StageInfo(False, False, None,                            "Team rankings computed")
]

assert len(STAGE_DATA) == len(TournStage)  # not ensured by zip
StageData = dict(zip(TournStage, STAGE_DATA))

#############
# TournInfo #
#############

class TournInfo(BaseModel):
    """
    """
    name           = TextField(unique=True)
    timeframe      = TextField(null=True)
    venue          = TextField(null=True)
    stage_start    = IntegerField()
    stage_compl    = IntegerField()
    cur_stage      = TextField()
    next_action    = TextField(null=True)
    players        = IntegerField(null=True)
    teams          = IntegerField(null=True)
    thm_teams      = IntegerField(null=True)
    seed_rounds    = IntegerField(default=DFLT_SEED_ROUNDS)
    tourn_rounds   = IntegerField(default=DFLT_TOURN_ROUNDS)
    divisions      = IntegerField(default=DFLT_DIVISIONS)

    # class variables
    inst: ClassVar[Self] = None  # singleton instance
    inst_name: ClassVar[str] = None

    @classmethod
    def get(cls, requery: bool = False) -> Self:
        """Return cached singleton instance (purposefully shadows more general base class
        method).
        """
        # NOTE: use iterator() to circumvent caching in ORM layer
        res = [t for t in cls.select().limit(2).iterator()]
        assert len(res) == 1  # fails if not initialized, or unexpected multiple records

        if cls.inst is None or res[0].name != cls.inst_name or requery:
            cls.inst = res[0]
            cls.inst_name = res[0].name
        return cls.inst

    @classmethod
    def mark_stage_start(cls, stage: TournStage) -> None:
        """Mark the start of the specified stage (and save) for the cached singleton
        """
        tourn = TournInfo.get()
        tourn.start_stage(stage)

    @classmethod
    def mark_stage_complete(cls, stage: TournStage) -> None:
        """Mark the completion of the specified stage (and save) for the cached singleton
        """
        tourn = TournInfo.get()
        tourn.complete_stage(stage)

    def save(self, *args, **kwargs):
        """Manage stage changes and associated message text
        """
        if 'stage_compl' in self._dirty:
            stage_data = StageData[self.stage_compl]

            if self.stage_start != self.stage_compl:
                assert not self.stage_start or self.stage_start < self.stage_compl
                # set stage_start implicitly (e.g. for for short operations)
                self.stage_start = self.stage_compl

            if stage_data.auto_advance:
                # this may overwrite the update above, but we leave things like this for
                # the associated integrity checking
                stage_next = self.stage_compl + 1
                self.stage_start = stage_next
                self.cur_stage = StageData[stage_next].start_msg
                self.next_action = StageData[stage_next].compl_msg
            else:
                self.cur_stage = stage_data.compl_msg
                stage_next = self.stage_compl + 1
                if stage_next < len(StageData):
                    self.next_action = StageData[stage_next].start_msg
                else:
                    self.next_action = None

            # TODO: should also log this information!!!
        if self.id is None:
            cls = type(self)
            cls.inst = None
            cls.inst_name = None
        return super().save(*args, **kwargs)

    def start_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the start of the specified stage (and save, by default)
        """
        self.stage_start = stage
        if auto_save:
            self.save()

    def complete_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the completion of the specified stage (and save, by default)
        """
        self.stage_compl = stage
        if auto_save:
            self.save()

##########
# Player #
##########

class Player(BaseModel):
    """
    """
    # required info
    first_name     = TextField()
    last_name      = TextField()
    nick_name      = TextField(unique=True)  # defaults to last_name
    reigning_champ = BooleanField(default=False)
    player_num     = IntegerField(unique=True, null=True)  # 1-based, must be contiguous
    # seeding round
    seed_wins      = IntegerField(null=True)
    seed_losses    = IntegerField(null=True)
    seed_win_pct   = FloatField(null=True)
    seed_pts_for   = IntegerField(null=True)
    seed_pts_against = IntegerField(null=True)
    seed_pts_diff  = IntegerField(null=True)
    seed_pts_pct   = FloatField(null=True)
    player_seed    = IntegerField(unique=True, null=True)  # 1-based
    # partner picks
    partner        = ForeignKeyField('self', field='player_num', column_name='partner_num',
                                     null=True)
    partner2       = ForeignKeyField('self', field='player_num', column_name='partner2_num',
                                     null=True)
    picked_by      = ForeignKeyField('self', field='player_num', column_name='picked_by_num',
                                     null=True)

    # class variables
    player_map: ClassVar[dict[int, Self]] = None  # indexed by player_num

    class Meta:
        indexes = (
            (('last_name', 'first_name'), True),
        )

    @classmethod
    def get_player_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all players, indexed by player_num
        """
        if cls.player_map and not requery:
            return cls.player_map

        cls.player_map = {}
        # see NOTE on use of iterator in `TournInfo.get`, above
        for p in cls.select().iterator():
            cls.player_map[p.player_num] = p
        return cls.player_map

    @classmethod
    def available_players(cls, requery: bool = False) -> list[Self]:
        """Return list of available players, sorted by player_seed
        """
        pl_list = cls.get_player_map(requery).values()
        avail = list(filter(lambda x: x.available, pl_list))
        return sorted(avail, key=lambda x: x.player_seed)

    @classmethod
    def active_picker(cls, requery: bool = False) -> Self:
        """Return top seeded player currently available, which equates to the player
        currently picking during the partner selection process
        """
        avail = cls.available_players(requery)
        if len(avail) == 0:
            raise LogicError("No available players")
        return avail[0]

    @classmethod
    def get_player(cls, player_num: int) -> Self:
        """Return player by player_num (from cached map)
        """
        pl_map = cls.get_player_map()
        return pl_map[player_num]

    @classmethod
    def fetch_by_seed(cls, player_seed: int) -> Self:
        """Return player by player_seed (always retrieved from database), or `None` if not
        found
        """
        return cls.get_or_none(cls.player_seed == player_seed)

    @classmethod
    def find_by_name_pfx(cls, name_pfx: str) -> Iterator[Self]:
        """Iterator returning players matching the specified (nick) name prefix
        """
        query = cls.select().where(cls.nick_name.startswith(name_pfx))
        for p in query.iterator():
            yield p

    @classmethod
    def iter_players(cls, by_seeding: bool = False) -> Iterator[Self]:
        """Iterator for players (wrap ORM details).  Note that this also clears out local
        cache, if populated.
        """
        if cls.player_map:
            cls.player_map = None

        query = cls.select()
        if by_seeding:
            query = query.order_by(cls.player_seed)
        # see NOTE on use of iterator in `TournInfo.get`, above
        for p in query.iterator():
            yield p

    @property
    def full_name(self) -> str:
        """For UI support (one field instead of two)
        """
        return self.first_name + ' ' + self.last_name

    @property
    def player_tag(self) -> str:
        """Combination of player_num and nick_name with embedded HTML annotation (used for
        bracket and scores/results displays)
        """
        return f"<b>{self.player_num}</b>&nbsp;&nbsp;<u>{self.nick_name}</u>"

    @property
    def champ(self) -> str | None:
        """For UI support ('y' or empty)
        """
        return 'y' if self.reigning_champ else None

    @property
    def available(self) -> str | None:
        """For partner picking UI; returns 'y' or None.  Note that this return value
        evaluates correctly as a boolean.
        """
        return 'y' if not (self.partner or self.picked_by) else None

    @property
    def seed_ident(self) -> str:
        """Player "name (seed)", for partner picking UI
        """
        return f"{self.nick_name} ({self.player_seed})"

    @property
    def picks_info(self) -> str | None:
        """For partner picking UI
        """
        pt_info = None
        if self.partner:
            pt_info = self.partner.seed_ident
            if self.partner2:
                pt_info += f", {self.partner2.seed_ident}"
        return pt_info

    @property
    def picked_by_info(self) -> str | None:
        """For partner picking UI
        """
        return self.picked_by.seed_ident if self.picked_by else None

    def pick_partners(self, partner: Self, partner2: Self = None) -> None:
        """
        """
        print(f"player: {self.player_num} ({self.nick_name})")
        print(f"  - picks partner {partner.player_num} ({partner.nick_name})")
        assert self.partner is None
        assert partner.picked_by is None
        self.partner = partner
        partner.picked_by = self

        if partner2:
            print(f"  - picks partner {partner2.player_num} ({partner2.nick_name})")
            assert self.partner2 is None
            assert partner2.picked_by is None
            self.partner2 = partner2
            partner2.picked_by = self

    def save(self, *args, **kwargs):
        """Ensure that nick_name is not null, since it is used as the display name in
        brackets (defaults to last_name if not otherwise specified)
        """
        if not self.nick_name:
            self.nick_name = self.last_name
        # cascade commit to partner(s), if dirty
        if self.partner and self.partner._dirty:
            self.partner.save()
            if self.partner2 and self.partner2._dirty:
                self.partner2.save()
        return super().save(*args, **kwargs)

############
# SeedGame #
############

class SeedGame(BaseModel):
    """
    """
    # required info
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # seed-{rnd}-{tbl}
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num',
                                     null=True)
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    player4        = ForeignKeyField(Player, field='player_num', column_name='player4_num',
                                     null=True)
    team1_name     = TextField(null=True)     # player1_name / player2_name
    team2_name     = TextField(null=True)     # player3_name / player4_name
    bye_players    = TextField(null=True)     # player1 / ...
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        # see NOTE on use of iterator in `TournInfo.get`, above
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.table_num.is_null(False))
        for t in sel.iterator():
            yield t

    @property
    def player_nums(self) -> str:
        """Used for the seeding view of the UI
        """
        pl_nums = list(filter(bool, (self.player1_num,
                                     self.player2_num,
                                     self.player3_num,
                                     self.player4_num)))
        if len(pl_nums) < 4:
            return ', '.join(map(str, pl_nums))

        return f"{pl_nums[0]} / {pl_nums[1]} vs. {pl_nums[2]} / {pl_nums[3]}"

    @property
    def team_tags(self) -> tuple[str, str]:
        """Team references based on player tags with embedded HTML annotation (used for
        bracket and scores/results displays)--currently, can only be called for actual
        matchup. and not bye records
        """
        p1 = self.player1
        p2 = self.player2
        p3 = self.player3
        p4 = self.player4
        assert p1 and p2 and p3 and p4
        team1_tag = f"{p1.player_tag}&nbsp;&nbsp;/&nbsp;&nbsp;{p2.player_tag}"
        team2_tag = f"{p3.player_tag}&nbsp;&nbsp;/&nbsp;&nbsp;{p4.player_tag}"
        return (team1_tag, team2_tag)

    @property
    def bye_tags(self) -> list[str]:
        """Bye references based on player tags with embedded HTML annotation (used for
        bracket and scores/results displays)--currently, can only be called for bye
        records
        """
        pl_list = list(filter(bool, (self.player1,
                                     self.player2,
                                     self.player3,
                                     self.player4)))
        assert len(pl_list) < 4  # ...or return None?
        return [pl.player_tag for pl in pl_list]

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  Scores should not be updated
        directly in model object, since denormalizations (e.g. in PlayerGame) will not be
        maintained (without some more involved pre-save logic).

        TODO: check to see if this overwrites a completed game result, in which case the
        denorms need to be properly managed!!!
        """
        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

        # insert records into PlayerGame for each player
        players     = [self.player1, self.player2, self.player3, self.player4]
        partners    = [self.player2, self.player1, self.player4, self.player3]
        opps_tups   = [(self.player3, self.player4), (self.player1, self.player2)]
        team_scores = [self.team1_pts, self.team2_pts]

        pl_games = []
        for pl_idx, player in enumerate(players):
            tm_idx    = pl_idx // 2
            op_idx    = tm_idx ^ 0x01
            partner   = partners[pl_idx]
            opps_tup  = opps_tups[tm_idx]
            team_pts  = team_scores[tm_idx]
            opp_pts   = team_scores[op_idx]

            pg_info = {'bracket'      : BRACKET_SEED,
                       'round_num'    : self.round_num,
                       'game_label'   : self.label,
                       'player'       : player,
                       'partners'     : [partner.player_num],
                       'opponents'    : [p.player_num for p in opps_tup],
                       'partner_names': [partner.nick_name],
                       'opp_names'    : [p.nick_name for p in opps_tup],
                       'team_pts'     : team_pts,
                       'opp_pts'      : opp_pts,
                       'is_winner'    : team_pts > opp_pts}
            pl_game = PlayerGame.create(**pg_info)
            pl_games.append(pl_game)

    def save(self, *args, **kwargs):
        """Compute winner if both scores have been entered
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in {self.team1_pts, self.team2_pts}:
                if self.team1_pts >= GAME_PTS:
                    assert self.team2_pts < GAME_PTS, f"both team scores > {GAME_PTS}"
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

########
# Team #
########

class Team(BaseModel):
    """
    """
    # required info
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num')
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    is_thm         = BooleanField(default=False)
    team_name      = TextField(unique=True)
    avg_player_seed = FloatField()
    top_player_seed = IntegerField()
    # tournament bracket
    team_seed      = IntegerField(unique=True, null=True)  # 1-based, from players seeds
    div_num        = IntegerField(null=True)
    div_seed       = IntegerField(null=True)
    # tournament play
    tourn_wins     = IntegerField(null=True)
    tourn_losses   = IntegerField(null=True)
    tourn_win_pct  = FloatField(null=True)
    tourn_pts_for  = IntegerField(null=True)
    tourn_pts_against = IntegerField(null=True)
    tourn_pts_diff = IntegerField(null=True)
    tourn_pts_pct  = FloatField(null=True)
    tourn_rank     = IntegerField(null=True)
    div_rank       = IntegerField(null=True)

    # class variables
    team_map: ClassVar[dict[int, Self]] = None  # indexed by team_seed

    class Meta:
        indexes = (
            (('div_num', 'div_seed'), True),
        )

    @classmethod
    def get_team_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all teams, indexed by team_seed
        """
        if cls.team_map and not requery:
            return cls.team_map

        cls.team_map = {}
        # see NOTE on use of iterator in `TournInfo.get`, above
        for t in cls.select().iterator():
            assert t.team_seed  # late check that seeds have been set
            cls.team_map[t.team_seed] = t
        return cls.team_map

    @classmethod
    def get_div_map(cls, div: int, requery: bool = False) -> dict[int, Self]:
        """Return dict of division teams, indexed by div_seed
        """
        tm_list = cls.get_team_map(requery).values()
        return {t.div_seed: t for t in tm_list if t.div_num == div}

    @classmethod
    def iter_teams(cls) -> Iterator[Self]:
        """Iterator for teams (wrap ORM details).  Note that this also clears out local
        cache, if populated.
        """
        if cls.team_map:
            cls.team_map = None

        # see NOTE on use of iterator in `TournInfo.get`, above
        for t in cls.select().iterator():
            yield t

    @property
    def team_tag(self) -> str:
        """Combination of div_seed and team_name with embedded HTML annotation (used for
        bracket and scores/results displays)
        """
        return f"<b>{self.div_seed}</b>&nbsp;&nbsp;<u>{self.team_name}</u>"

    @property
    def player_nums(self) -> str:
        """
        """
        pl_nums = list(filter(bool, (self.player1_num,
                                     self.player2_num,
                                     self.player3_num)))
        return ' / '.join(map(str, pl_nums))

    @property
    def avg_player_seed_rnd(self) -> float:
        """Round avg_player_seed for display purposes
        """
        return round(self.avg_player_seed, 2)

#############
# TournGame #
#############

class TournGame(BaseModel):
    """
    """
    # required info
    div_num        = IntegerField()
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # rr-{div}-{rnd}-{tbl}
    team1          = ForeignKeyField(Team, field='team_seed', column_name='team1_seed')
    team2          = ForeignKeyField(Team, field='team_seed', column_name='team2_seed', null=True)
    team1_name     = TextField(null=True)     # denorm (null if team1 is bye_team)
    team2_name     = TextField(null=True)     # denorm
    bye_team       = TextField(null=True)
    team1_div_seed = IntegerField()
    team2_div_seed = IntegerField(null=True)
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('div_num', 'round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        # see NOTE on use of iterator in `TournInfo.get`, above
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.table_num.is_null(False))
        for t in sel.iterator():
            yield t

    @property
    def team_seeds(self) -> str:
        """
        """
        tm_seeds = (self.team1_div_seed, self.team2_div_seed)
        return ' vs. '.join(str(x) for x in tm_seeds if x)

    @property
    def team_tags(self) -> tuple[str, str]:
        """Team tags with embedded HTML annotation (used for bracket and scores/results
        displays)--currently, can only be called for actual matchup. and not bye records
        """
        assert self.team1 and self.team2
        return (self.team1.team_tag, self.team2.team_tag)

    @property
    def bye_tag(self) -> str:
        """Bye reference based on team tags with embedded HTML annotation (used for
        bracket and scores/results displays)--currently, can only be called for bye
        records
        """
        assert self.team1 and self.team2 is None  # ...or return None?
        return self.team1.team_tag

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  Scores should not be updated
        directly in model object, since denormalizations (e.g. in TeamGame) will not be
        maintained (without some more involved pre-save logic).

        TODO: check to see if this overwrites a completed game result, in which case the
        denorms need to be properly managed!!!
        """
        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

        # insert records into TeamGame for each team
        teams       = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        tm_games = []
        for tm_idx, team in enumerate([self.team1, self.team2]):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            tg_info = {'bracket'   : BRACKET_TOURN,
                       'round_num' : self.round_num,
                       'game_label': self.label,
                       'team'      : team,
                       'opponent'  : teams[op_idx],
                       'team_team' : team.team_name,
                       'opp_name'  : teams[op_idx].team_name,
                       'team_pts'  : team_pts,
                       'opp_pts'   : opp_pts,
                       'is_winner' : team_pts > opp_pts}
            tm_game = TeamGame.create(**tg_info)
            tm_games.append(tm_game)

    def save(self, *args, **kwargs):
        """Compute winner if both scores have been entered
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in {self.team1_pts, self.team2_pts}:
                if self.team1_pts >= GAME_PTS:
                    assert self.team2_pts < GAME_PTS, f"both team scores > {GAME_PTS}"
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

##############
# PlayerGame #
##############

class PlayerGame(BaseModel):
    """Denormalization of SeedGame (and possibly TournGame data), for use in computing
    stats, determining head-to-head match-ups, etc.
    """
    bracket        = TextField()            # "seed", "rr", or "playoff"
    round_num      = IntegerField()
    game_label     = TextField()            # seed-rnd-tbl or rr-div-rnd-tbl
    player         = ForeignKeyField(Player, field='player_num', column_name='player_num')
    player_name    = TextField()            # automatic denorm
    partners       = JSONField(default=[])  # array of partner player_num(s)
    opponents      = JSONField(default=[])  # array of opposing player_nums
    partner_names  = JSONField(default=[])  # denorm
    opp_names      = JSONField(default=[])  # denorm
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'player'), True),
            (('game_label', 'player'), True)
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        # see NOTE on use of iterator in `TournInfo.get`, above
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.is_bye == False)
        for t in sel.iterator():
            yield t

    def save(self, *args, **kwargs):
        """Set player name (denorm field) as player's nick name
        """
        if not self.player_name:
            self.player_name = self.player.nick_name
        return super().save(*args, **kwargs)

##############
# TeamGame #
##############

class TeamGame(BaseModel):
    """Denormalization of TournGame data, for use in computing stats, determining
    head-to-head match-ups, etc.
    """
    bracket        = TextField()           # "rr" or "playoff"
    round_num      = IntegerField()
    game_label     = TextField()           # e.g. rr-div-rnd-tbl
    team           = ForeignKeyField(Team, field='team_seed', column_name='team_seed')
    opponent       = ForeignKeyField(Team, field='team_seed', column_name='opp_seed', null=True)
    team_name      = TextField()
    opp_name       = TextField(null=True)  # or "bye"(?)
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'team'), True),
            (('game_label', 'team'), True)
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for tourn_games (wrap ORM details).
        """
        # see NOTE on use of iterator in `TournInfo.get`, above
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.is_bye == False)
        for t in sel.iterator():
            yield t

    def save(self, *args, **kwargs):
        """Set team and opponane names (denorm fields)
        """
        if not self.team_name:
            self.team_name = self.team.team_name
        if self.opponent and not self.opp_name:
            self.opp_name = self.opponent.team_name
        return super().save(*args, **kwargs)

#################
# schema_create #
#################

ALL_MODELS = [TournInfo, Player, SeedGame, Team, TournGame, PlayerGame, TeamGame]

def schema_create(models: list[BaseModel | str] | str = None, force = False) -> None:
    """Create tables for specified models (list of objects or comma-separated list of
    names), or all models if no list is specified.
    """
    if models is None:
        models = ALL_MODELS
    elif isinstance(models, str):
        models = models.split(',')
    assert isinstance(models, list)
    if isinstance(models[0], str):
        models_new = []
        for model in models:
            if model not in globals():
                raise RuntimeError(f"Model {model} not imported")
            model_obj = globals()[model]
            if not issubclass(model_obj, BaseModel):
                raise RuntimeError(f"Model {model} must be subclass of `BaseModel`")
            models_new.append(model_obj)
        models = models_new

    # TEMP: just drop all tables, so we don't have to worry about integrity, cascading
    # deletes, legacy data, etc.
    if force:
        for model in reversed(models):
            model.drop_table()

    for model in models:
        try:
            model.create_table(safe=False)
        except OperationalError as e:
            if re.fullmatch(r'table "(\w+)" already exists', str(e)) and force:
                model.drop_table(safe=False)
                model.create_table(safe=False)
            else:
                raise
