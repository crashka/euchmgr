#!/usr/bin/env python
# -*- coding: utf-8 -*-

from enum import IntEnum
from typing import ClassVar, Self, Iterator, NamedTuple
import re

from peewee import (TextField, IntegerField, BooleanField, ForeignKeyField, FloatField,
                    OperationalError)
from playhouse.sqlite_ext import JSONField

from database import BaseModel

DFLT_SEED_ROUNDS  = 8
DFLT_TOURN_ROUNDS = 8
DFLT_DIVISIONS    = 2

GAME_PTS          = 10

BRACKET_SEED      = 'seed'
BRACKET_TOURN     = 'rr'
BRACKET_PLAYOFF   = 'playoff'

# stage values are chronologically sequenced
TournStage = IntEnum('TournStage',
                     ['TOURN_CREATE',
                      'PLAYER_ROSTER',
                      'PLAYER_NUMS',
                      'SEED_BRACKET',
                      'SEED_RESULTS',
                      'SEED_TABULATE',
                      'SEED_RANKS',
                      'PARTNER_PICK',
                      'TOURN_TEAMS',
                      'TEAM_SEEDS',
                      'TOURN_BRACKET',
                      'TOURN_RESULTS',
                      'TOURN_TABULATE',
                      'TEAM_RANKS'])

class StageInfo(NamedTuple):
    """Behavior parameters and status messages for tournament stages

    REVISIT(?): there is currently redundancy in the two boolean flags, but we may keep it
    this way for integrity checking
    """
    long_running: bool  # possible manual data entry/finalization in order to complete
    auto_advance: bool  # start next stage automatically upon completion
    start_msg:    str   # only needed if long_running
    compl_msg:    str   # not visible if auto_advance (though specified regardless)

# NOTE that we are being a little particular/pedantic about wording for messages here:
# - "seed" means assigned position within a bracket based on past performance
# - "seeding" means the seeding round process
# - "round robin" means the main tournament, not including playoffs
# - "playoffs" means the semi-final and final rounds of the tournament
# - "rank" or "ranking" means finish position after play is over
# - "position" means order on the scale of performance during play
# - "completed" means data entry of an activity (e.g. playing or picking) is done
# - "computed" or "tabulated" means something algorithmically generated by the program
# - "assigned" means the completion of a process that may be either manual or automated
#
STAGE_DATA = [
    StageInfo(False, True,  None,                      "New tournament"),
    StageInfo(True,  True,  "Creating player roster",  "Player roster created"),
    StageInfo(True,  False, "Assigning player nums",   "Player nums assigned"),
    StageInfo(False, True,  None,                      "Seeding bracket created"),
    StageInfo(True , False, "Seeding round active",    "Seeding results completed"),
    StageInfo(False, False, None,                      "Seeding results tabulated"),
    StageInfo(False, True,  None,                      "Seeding rankings computed"),
    StageInfo(True,  False, "Picking partners",        "Partner picks completed"),
    StageInfo(False, False, None,                      "Round robin teams created"),
    StageInfo(False, False, None,                      "Round robin team seeds computed"),
    StageInfo(False, True,  None,                      "Round robin brackets created"),
    StageInfo(True,  False, "Round robin play active", "Round robin results completed"),
    StageInfo(False, False, None,                      "Round robin results tabulated"),
    StageInfo(False, False, None,                      "Team rankings computed")
]

assert len(STAGE_DATA) == len(TournStage)  # not ensured by zip
StageData = dict(zip(TournStage, STAGE_DATA))

#############
# TournInfo #
#############

class TournInfo(BaseModel):
    """
    """
    name           = TextField(unique=True)
    timeframe      = TextField(null=True)
    venue          = TextField(null=True)
    stage_start    = IntegerField()
    stage_compl    = IntegerField()
    status         = TextField()
    players        = IntegerField(null=True)
    teams          = IntegerField(null=True)
    thm_teams      = IntegerField(null=True)
    seed_rounds    = IntegerField(default=DFLT_SEED_ROUNDS)
    tourn_rounds   = IntegerField(default=DFLT_TOURN_ROUNDS)
    divisions      = IntegerField(default=DFLT_DIVISIONS)

    # class variables
    inst: ClassVar[Self] = None  # singleton instance
    inst_name: ClassVar[str] = None

    @classmethod
    def get(cls, requery: bool = False) -> Self:
        """Return cached singleton instance (purposefully shadows more general base class
        method).
        """
        # NOTE: use iterator() to circumvent caching in ORM layer
        res = [t for t in cls.select().limit(2).iterator()]
        assert len(res) == 1  # fails if not initialized, or unexpected multiple records

        if cls.inst is None or res[0].name != cls.inst_name or requery:
            cls.inst = res[0]
            cls.inst_name = res[0].name
        return cls.inst

    @classmethod
    def mark_stage_start(cls, stage: TournStage) -> None:
        """Mark the start of the specified stage (and save) for the cached singleton
        """
        tourn = TournInfo.get()
        tourn.start_stage(stage)

    @classmethod
    def mark_stage_complete(cls, stage: TournStage) -> None:
        """Mark the completion of the specified stage (and save) for the cached singleton
        """
        tourn = TournInfo.get()
        tourn.complete_stage(stage)

    def save(self, *args, **kwargs):
        """Manage stage/status changes
        """
        if 'stage_compl' in self._dirty:
            stage_data = StageData[self.stage_compl]

            if self.stage_start != self.stage_compl:
                assert not self.stage_start or self.stage_start < self.stage_compl
                # set stage_start implicitly (e.g. for for short operations)
                self.stage_start = self.stage_compl

            if stage_data.auto_advance:
                # this may overwrite the update above, but we leave things like this for
                # the associated integrity checking
                next_stage = self.stage_compl + 1
                self.stage_start = next_stage
                self.status = StageData[next_stage].start_msg
            else:
                self.status = stage_data.compl_msg

            # TODO: should also log this information!!!
        return super().save(*args, **kwargs)

    def start_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the start of the specified stage (and save, by default)
        """
        self.stage_start = stage
        if auto_save:
            self.save()

    def complete_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the completion of the specified stage (and save, by default)
        """
        self.stage_compl = stage
        if auto_save:
            self.save()

##########
# Player #
##########

class Player(BaseModel):
    """
    """
    # required info
    first_name     = TextField()
    last_name      = TextField()
    nick_name      = TextField(unique=True)  # defaults to last_name
    reigning_champ = BooleanField(default=False)
    player_num     = IntegerField(unique=True, null=True)  # 1-based, must be contiguous
    # seeding round
    seed_wins      = IntegerField(null=True)
    seed_losses    = IntegerField(null=True)
    seed_win_pct   = FloatField(null=True)
    seed_pts_for   = IntegerField(null=True)
    seed_pts_against = IntegerField(null=True)
    seed_pts_diff  = IntegerField(null=True)
    seed_pts_pct   = FloatField(null=True)
    player_seed    = IntegerField(unique=True, null=True)  # 1-based
    # partner picks
    partner        = ForeignKeyField('self', field='player_num', column_name='partner_num',
                                     null=True)
    partner2       = ForeignKeyField('self', field='player_num', column_name='partner2_num',
                                     null=True)
    picked_by      = ForeignKeyField('self', field='player_num', column_name='picked_by_num',
                                     null=True)

    # class variables
    player_map: ClassVar[dict[int, Self]] = None  # indexed by player_num

    class Meta:
        indexes = (
            (('last_name', 'first_name'), True),
        )

    @classmethod
    def get_player_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all players, indexed by player_num
        """
        if cls.player_map and not requery:
            return cls.player_map

        cls.player_map = {}
        # see NOTE on use of iterator in `TournInfo.get`, above
        for p in cls.select().iterator():
            cls.player_map[p.player_num] = p
        return cls.player_map

    @classmethod
    def get_player(cls, player_num: int) -> Self:
        """Return player by player_num (from cached map)
        """
        pl_map = cls.get_player_map()
        return pl_map[player_num]

    @classmethod
    def iter_players(cls) -> Iterator[Self]:
        """Iterator for players (wrap ORM details).  Note that this also clears out local
        cache, if populated.
        """
        if cls.player_map:
            cls.player_map = None

        # see NOTE on use of iterator in `TournInfo.get`, above
        for p in cls.select().iterator():
            yield p

    def pick_partners(self, partner1: Self, partner2: Self = None) -> None:
        """
        """
        print(f"player: {self.player_num} ({self.nick_name})")
        print(f"  - picks partner {partner1.player_num} ({partner1.nick_name})")
        assert self.partner_num is None
        assert partner1.picked_by_num is None
        self.partner_num = partner1.player_num
        partner1.picked_by_num = self.player_num

        if partner2:
            print(f"  - picks partner {partner2.player_num} ({partner2.nick_name})")
            assert self.partner2_num is None
            assert partner2.picked_by_num is None
            self.partner2_num = partner2.player_num
            partner2.picked_by_num = self.player_num

    def save(self, *args, **kwargs):
        """Ensure that nick_name is not null, since it is used as the display name in
        brackets (defaults to last_name if not otherwise specified)
        """
        if not self.nick_name:
            self.nick_name = self.last_name
        return super().save(*args, **kwargs)

############
# SeedGame #
############

class SeedGame(BaseModel):
    """
    """
    # required info
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # seed-{rnd}-{tbl}
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num',
                                     null=True)
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    player4        = ForeignKeyField(Player, field='player_num', column_name='player4_num',
                                     null=True)
    team1_name     = TextField(null=True)     # player1_name / player2_name
    team2_name     = TextField(null=True)     # player3_name / player4_name
    bye_players    = TextField(null=True)     # player1 / ...
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        # see NOTE on use of iterator in `TournInfo.get`, above
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.table_num.is_null(False))
        for t in sel.iterator():
            yield t

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  Scores should not be updated
        directly in model object, since denormalizations (e.g. in PlayerGame) will not be
        maintained (without some more involved pre-save logic).

        TODO: check to see if this overwrites a completed game result, in which case the
        denorms need to be properly managed!!!
        """
        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

        if self.team1_pts >= GAME_PTS:
            assert self.team2_pts < GAME_PTS
            self.winner = self.team1_name
        elif self.team2_pts >= GAME_PTS:
            self.winner = self.team2_name
        else:
            self.winner = None

        # insert records into PlayerGame for each player
        players     = [self.player1, self.player2, self.player3, self.player4]
        partners    = [self.player2, self.player1, self.player4, self.player3]
        opps_tups   = [(self.player3, self.player4), (self.player1, self.player2)]
        team_scores = [self.team1_pts, self.team2_pts]

        pl_games = []
        for pl_idx, player in enumerate(players):
            tm_idx    = pl_idx // 2
            op_idx    = tm_idx ^ 0x01
            partner   = partners[pl_idx]
            opps_tup  = opps_tups[tm_idx]
            team_pts  = team_scores[tm_idx]
            opp_pts   = team_scores[op_idx]

            pg_info = {'bracket'      : BRACKET_SEED,
                       'round_num'    : self.round_num,
                       'game_label'   : self.label,
                       'player'       : player,
                       'partners'     : [partner.player_num],
                       'opponents'    : [p.player_num for p in opps_tup],
                       'partner_names': [partner.nick_name],
                       'opp_names'    : [p.nick_name for p in opps_tup],
                       'team_pts'     : team_pts,
                       'opp_pts'      : opp_pts,
                       'is_winner'    : team_pts > opp_pts}
            pl_game = PlayerGame.create(**pg_info)
            pl_games.append(pl_game)

########
# Team #
########

class Team(BaseModel):
    """
    """
    # required info
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num')
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    is_thm         = BooleanField(default=False)
    team_name      = TextField(unique=True)
    avg_player_seed = FloatField()
    top_player_seed = IntegerField()
    # tournament bracket
    team_seed      = IntegerField(unique=True, null=True)  # 1-based, from players seeds
    div_num        = IntegerField(null=True)
    div_seed       = IntegerField(null=True)
    # tournament play
    tourn_wins     = IntegerField(null=True)
    tourn_losses   = IntegerField(null=True)
    tourn_win_pct  = FloatField(null=True)
    tourn_pts_for  = IntegerField(null=True)
    tourn_pts_against = IntegerField(null=True)
    tourn_pts_diff = IntegerField(null=True)
    tourn_pts_pct  = FloatField(null=True)
    tourn_rank     = IntegerField(null=True)
    div_rank       = IntegerField(null=True)

    # class variables
    team_map: ClassVar[dict[int, Self]] = None  # indexed by team_seed

    class Meta:
        indexes = (
            (('div_num', 'div_seed'), True),
        )

    @classmethod
    def get_team_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all teams, indexed by team_seed
        """
        if cls.team_map and not requery:
            return cls.team_map

        cls.team_map = {}
        # see NOTE on use of iterator in `TournInfo.get`, above
        for t in cls.select().iterator():
            assert t.team_seed  # late check that seeds have been set
            cls.team_map[t.team_seed] = t
        return cls.team_map

    @classmethod
    def get_div_map(cls, div: int, requery: bool = False) -> dict[int, Self]:
        """Return dict of division teams, indexed by div_seed
        """
        tm_list = cls.get_team_map(requery).values()
        return {t.div_seed: t for t in tm_list if t.div_num == div}

    @classmethod
    def iter_teams(cls) -> Iterator[Self]:
        """Iterator for teams (wrap ORM details).  Note that this also clears out local
        cache, if populated.
        """
        if cls.team_map:
            cls.team_map = None

        # see NOTE on use of iterator in `TournInfo.get`, above
        for t in cls.select().iterator():
            yield t

#############
# TournGame #
#############

class TournGame(BaseModel):
    """
    """
    # required info
    div_num        = IntegerField()
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # rr-{div}-{rnd}-{tbl}
    team1          = ForeignKeyField(Team, field='team_seed', column_name='team1_seed')
    team2          = ForeignKeyField(Team, field='team_seed', column_name='team2_seed', null=True)
    team1_name     = TextField()              # denorm
    team2_name     = TextField()              # denorm (or BYE_TEAM)
    team1_div_seed = IntegerField()
    team2_div_seed = IntegerField(null=True)
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('div_num', 'round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        # see NOTE on use of iterator in `TournInfo.get`, above
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.table_num.is_null(False))
        for t in sel.iterator():
            yield t

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  Scores should not be updated
        directly in model object, since denormalizations (e.g. in PlayerGame) will not be
        maintained (without some more involved pre-save logic).

        TODO: check to see if this overwrites a completed game result, in which case the
        denorms need to be properly managed!!!
        """
        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

        if self.team1_pts >= GAME_PTS:
            assert self.team2_pts < GAME_PTS
            self.winner = self.team1_name
        elif self.team2_pts >= GAME_PTS:
            self.winner = self.team2_name
        else:
            self.winner = None

        # insert records into PlayerGame for each player
        teams       = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        tm_games = []
        for tm_idx, team in enumerate([self.team1, self.team2]):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            tg_info = {'bracket'   : BRACKET_TOURN,
                       'round_num' : self.round_num,
                       'game_label': self.label,
                       'team'      : team,
                       'opponent'  : teams[op_idx],
                       'team_team' : team.team_name,
                       'opp_name'  : teams[op_idx].team_name,
                       'team_pts'  : team_pts,
                       'opp_pts'   : opp_pts,
                       'is_winner' : team_pts > opp_pts}
            tm_game = TeamGame.create(**tg_info)
            tm_games.append(tm_game)

##############
# PlayerGame #
##############

class PlayerGame(BaseModel):
    """Denormalization of SeedGame (and possibly TournGame data), for use in computing
    stats, determining head-to-head match-ups, etc.
    """
    bracket        = TextField()            # "seed", "rr", or "playoff"
    round_num      = IntegerField()
    game_label     = TextField()            # seed-rnd-tbl or rr-div-rnd-tbl
    player         = ForeignKeyField(Player, field='player_num', column_name='player_num')
    player_name    = TextField()            # automatic denorm
    partners       = JSONField(default=[])  # array of partner player_num(s)
    opponents      = JSONField(default=[])  # array of opposing player_nums
    partner_names  = JSONField(default=[])  # denorm
    opp_names      = JSONField(default=[])  # denorm
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'player'), True),
            (('game_label', 'player'), True)
        )

    def save(self, *args, **kwargs):
        """Set player name (denorm field) as player's nick name
        """
        if not self.player_name:
            self.player_name = self.player.nick_name
        return super().save(*args, **kwargs)

##############
# TeamGame #
##############

class TeamGame(BaseModel):
    """Denormalization of TournGame data, for use in computing stats, determining
    head-to-head match-ups, etc.
    """
    bracket        = TextField()           # "rr" or "playoff"
    round_num      = IntegerField()
    game_label     = TextField()           # e.g. rr-div-rnd-tbl
    team           = ForeignKeyField(Team, field='team_seed', column_name='team_seed')
    opponent       = ForeignKeyField(Team, field='team_seed', column_name='opp_seed', null=True)
    team_name      = TextField()
    opp_name       = TextField(null=True)  # or "bye"(?)
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'team'), True),
            (('game_label', 'team'), True)
        )

    def save(self, *args, **kwargs):
        """Set team and opponane names (denorm fields)
        """
        if not self.team_name:
            self.team_name = self.team.team_name
        if self.opponent and not self.opp_name:
            self.opp_name = self.opponent.team_name
        return super().save(*args, **kwargs)

#################
# schema_create #
#################

ALL_MODELS = [TournInfo, Player, SeedGame, Team, TournGame, PlayerGame, TeamGame]

def schema_create(models: list[BaseModel | str] | str = None, force = False) -> None:
    """Create tables for specified models (list of objects or comma-separated list of
    names), or all models if no list is specified.
    """
    if models is None:
        models = ALL_MODELS
    elif isinstance(models, str):
        models = models.split(',')
    assert isinstance(models, list)
    if isinstance(models[0], str):
        models_new = []
        for model in models:
            if model not in globals():
                raise RuntimeError(f"Model {model} not imported")
            model_obj = globals()[model]
            if not issubclass(model_obj, BaseModel):
                raise RuntimeError(f"Model {model} must be subclass of `BaseModel`")
            models_new.append(model_obj)
        models = models_new

    # TEMP: just drop all tables, so we don't have to worry about integrity, cascading
    # deletes, legacy data, etc.
    if force:
        for model in reversed(models):
            model.drop_table()

    for model in models:
        try:
            model.create_table(safe=False)
        except OperationalError as e:
            if re.fullmatch(r'table "(\w+)" already exists', str(e)) and force:
                model.drop_table(safe=False)
                model.create_table(safe=False)
            else:
                raise
