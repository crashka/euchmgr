# -*- coding: utf-8 -*-

from enum import IntEnum, StrEnum
from typing import ClassVar, Self, Iterator, NamedTuple
import re

from peewee import (TextField, IntegerField, BooleanField, FloatField, ForeignKeyField,
                    DeferredForeignKey, OperationalError, DoesNotExist, fn)
from playhouse.sqlite_ext import JSONField
from werkzeug.security import generate_password_hash, check_password_hash

from core import DEBUG, log, ImplementationError, LogicError, DataError
from security import current_user, login_user, logout_user, EuchmgrUser, AuthenticationError
from database import BaseModel

#################
# utility stuff #
#################

# hard-wired floating point precision (depending on field type), helpful for neater
# display as well as equivalence determination (without additional rounding)
rnd_pct = lambda x: round(x, 5)
rnd_avg = lambda x: round(x, 2)

def clear_schema_cache() -> None:
    """This needs to be called every time we switch (or reset) databases.

    FIX: this is currently only called from `conftest.py`, but also needs to be
    incorporated into the database management logic in `server.py`!!!
    """
    TournInfo.clear_cache()

######################
# bracket/game stuff #
######################

DFLT_SEED_ROUNDS  = 8
DFLT_TOURN_ROUNDS = 8
DFLT_DIVISIONS    = 2

GAME_PTS          = 10

class Bracket(StrEnum):
    SEED   = 'sd'
    TOURN  = 'rr'  # for "round robin"
    SEMIS  = 'sf'
    FINALS = 'fn'

BRACKET_NAME = {
    Bracket.SEED  : "Seeding",
    Bracket.TOURN : "Round Robin",
    Bracket.SEMIS : "Semifinals",
    Bracket.FINALS: "Finals",
}

##########################
# tournament stage stuff #
##########################

# stage values are chronologically sequenced
TournStage = IntEnum('TournStage',
                     ['TOURN_CREATE',    # 1
                      'PLAYER_ROSTER',
                      'PLAYER_NUMS',
                      'SEED_BRACKET',
                      'SEED_RESULTS',    # 5
                      'SEED_TABULATE',
                      'SEED_RANKS',
                      'PARTNER_PICK',
                      'TOURN_TEAMS',
                      'TEAM_SEEDS',      # 10
                      'TOURN_BRACKET',
                      'TOURN_RESULTS',
                      'TOURN_TABULATE',
                      'TOURN_RANKS',
                      'SEMIS_BRACKET',   # 15
                      'SEMIS_RESULTS',
                      'SEMIS_TABULATE',
                      'SEMIS_RANKS',
                      'FINALS_BRACKET',
                      'FINALS_RESULTS',  # 20
                      'FINALS_TABULATE',
                      'FINALS_RANKS'])

# represents virtual stages before and after TournStage entries
TOURN_INIT = 0
TOURN_FINAL = len(TournStage) + 1
ALL_STAGES = range(TOURN_INIT, TOURN_FINAL)
ACTIVE_STAGES = range(TournStage.PLAYER_ROSTER, TOURN_FINAL)

class StageInfo(NamedTuple):
    """Behavior parameters and messages for tournament stages

    REVISIT(?): there is currently redundancy in the two boolean flags, but we may keep it
    this way for integrity checking
    """
    long_running: bool  # possible manual data entry/finalization in order to complete
    auto_advance: bool  # start next stage automatically upon completion
    start_msg:    str   # only needed if long_running
    compl_msg:    str   # not visible if auto_advance (though specified regardless)

# NOTE that we are being a little particular/pedantic about wording for messages here:
# - "seed" means assigned position within a bracket based on past performance
# - "seeding" means the seeding round process
# - "round robin" means the main tournament, not including playoffs
# - "playoffs" means the semi-final and final rounds of the tournament
# - "rank" or "ranking" means finish position after play is over
# - "position" means order on the scale of performance during play
# - "completed" means data entry of an activity (e.g. playing or picking) is done
# - "computed" or "tabulated" means something algorithmically generated by the program
# - "assigned" means the completion of a process that may be either manual or automated
#
STAGE_DATA = [
    StageInfo(False, False, None,                            "New tournament"),
    StageInfo(True,  True,  "Creating player roster",        "Player roster created"),
    StageInfo(True,  False, "Assigning player nums",         "Player nums assigned"),
    StageInfo(False, True,  "Generate seeding bracket",      "Seeding bracket created"),
    StageInfo(True , False, "Seeding round active",          "Seeding results completed"),
    StageInfo(False, False, "Tabulate seeding results",      "Seeding results tabulated"),
    StageInfo(False, True,  None,                            "Seeding rankings computed"),
    StageInfo(True,  False, "Picking partners",              "Partner picks completed"),
    StageInfo(False, False, "Generate round robin brackets", "Round robin teams created"),
    StageInfo(False, False, None,                            "Round robin team seeds computed"),
    StageInfo(False, True,  None,                            "Round robin brackets created"),
    StageInfo(True,  False, "Round robin play active",       "Round robin results completed"),
    StageInfo(False, False, "Tabulate round robin results",  "Round robin results tabulated"),
    StageInfo(False, False, None,                            "Team rankings computed"),
    StageInfo(False, True,  None,                            "Semifinals brackets created"),
    StageInfo(True,  False, "Semifinals play active",        "Semifinals results completed"),
    StageInfo(False, False, "Tabulate semifinals results",   "Semifinals results tabulated"),
    StageInfo(False, False, None,                            "Semifinals rankings computed"),
    StageInfo(False, True,  None,                            "Finals brackets created"),
    StageInfo(True,  False, "Finals play active",            "Finals results completed"),
    StageInfo(False, False, "Tabulate finals results",       "Finals results tabulated"),
    StageInfo(False, False, None,                            "Finals rankings computed")
]

assert len(STAGE_DATA) == len(TournStage)  # not ensured by zip
StageData = dict(zip(TournStage, STAGE_DATA))

#############
# TournInfo #
#############

HIDDEN_TOURN_FLDS = ['dflt_pw_hash']

class TournInfo(BaseModel):
    """High-level tournament information.  There is only one instance per database (since
    the database encapsulates the entire data for a single tournament).
    """
    name           = TextField(unique=True)
    dates          = TextField(null=True)
    venue          = TextField(null=True)
    stage_start    = IntegerField()
    stage_compl    = IntegerField()
    cur_stage      = TextField()
    next_action    = TextField(null=True)
    players        = IntegerField(null=True)
    teams          = IntegerField(null=True)
    thm_teams      = IntegerField(null=True)
    seed_rounds    = IntegerField(default=DFLT_SEED_ROUNDS)
    tourn_rounds   = IntegerField(default=DFLT_TOURN_ROUNDS)
    divisions      = IntegerField(default=DFLT_DIVISIONS)
    dflt_pw_hash   = TextField(null=True)  # initial/default pw_hash for players

    # class variables
    inst: ClassVar[Self] = None  # singleton instance

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above).
        """
        if cls != TournInfo:
            raise ImplementationError(f"cannot cache TournInfo subclass instance")
        cls.inst = None

    @classmethod
    def get(cls, requery: bool = False) -> Self:
        """Return cached singleton instance (purposefully shadows more general base class
        method).
        """
        if cls != TournInfo:
            raise ImplementationError(f"cannot cache TournInfo subclass instance")
        if cls.inst is None or requery:
            res = [t for t in cls.select().limit(2)]
            assert len(res) == 1  # fails if not initialized, or unexpected multiple records
            cls.inst = res[0]
        return cls.inst

    @classmethod
    def mark_stage_start(cls, stage: TournStage) -> None:
        """Mark the start of the specified stage (and save) for the cached singleton.
        """
        tourn = TournInfo.get()
        tourn.start_stage(stage)

    @classmethod
    def mark_stage_complete(cls, stage: TournStage) -> None:
        """Mark the completion of the specified stage (and save) for the cached singleton.
        """
        tourn = TournInfo.get()
        tourn.complete_stage(stage)

    @property
    def tourn_data(self) -> dict:
        """Return tournament data as a dict, removing hidden values.
        """
        data = {k: v for k, v in self.__data__.items() if k not in HIDDEN_TOURN_FLDS}
        return data

    def save(self, *args, **kwargs):
        """Manage stage changes and associated message text.
        """
        if 'stage_compl' in self._dirty:
            stage_data = StageData[self.stage_compl]

            if self.stage_start != self.stage_compl:
                assert not self.stage_start or self.stage_start < self.stage_compl
                # set stage_start implicitly (e.g. for for short operations)
                self.stage_start = self.stage_compl

            if stage_data.auto_advance:
                # this may overwrite the update above, but we leave things like this for
                # the associated integrity checking
                stage_next = self.stage_compl + 1
                self.stage_start = stage_next
                self.cur_stage = StageData[stage_next].start_msg
                self.next_action = StageData[stage_next].compl_msg
            else:
                self.cur_stage = stage_data.compl_msg
                stage_next = self.stage_compl + 1
                if stage_next < len(StageData):
                    self.next_action = StageData[stage_next].start_msg
                else:
                    self.next_action = None
            # TODO: should also log this information!!!

        if self.id is None:
            self.__class__.clear_cache()
        return super().save(*args, **kwargs)

    def start_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the start of the specified stage (and save, by default).
        """
        self.stage_start = stage
        if auto_save:
            self.save()

    def complete_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the completion of the specified stage (and save, by default).
        """
        self.stage_compl = stage
        if auto_save:
            self.save()

    def seeding_done(self) -> bool:
        """Official way to check if seeding is complete (scores validated and final player
        rankings computed).
        """
        return self.stage_compl >= TournStage.SEED_RANKS

    def partner_picks_done(self) -> bool:
        """Official way to check if partner picking is complete (all picks made and teams
        determined).
        """
        return self.stage_compl >= TournStage.TOURN_TEAMS

    def round_robin_done(self) -> bool:
        """Official way to check if round robin is complete (scores validated and final
        team rankings computed).
        """
        return self.stage_compl >= TournStage.TOURN_RANKS

    def playoffs_done(self) -> bool:
        """Official way to check if playoffs (and hence the tournament) is complete
        (scores validated and final team rankings computed).
        """
        return self.stage_compl >= TournStage.FINALS_RANKS

##########
# Player #
##########

EMPTY_PLYR_STATS = {
    'seed_wins'       : None,
    'seed_losses'     : None,
    'seed_pts_for'    : None,
    'seed_pts_against': None
}

class Player(BaseModel, EuchmgrUser):
    """Represents a player in the tournament, as well as a mobile (i.e. non-admin) user of
    the app.
    """
    # identifying info
    first_name     = TextField()
    last_name      = TextField()
    nick_name      = TextField(unique=True)  # serves as player_name (defaults to last_name)
    reigning_champ = BooleanField(default=False)
    player_num     = IntegerField(unique=True, null=True)  # 1-based, must be contiguous
    pw_hash        = TextField(null=True)    # default pw_hash (in TournInfo) is used, if null
    # seeding round
    seed_wins      = IntegerField(default=0)
    seed_losses    = IntegerField(default=0)
    seed_win_pct   = FloatField(null=True)
    seed_pts_for   = IntegerField(default=0)
    seed_pts_against = IntegerField(default=0)
    seed_pts_pct   = FloatField(null=True)
    player_pos     = IntegerField(null=True)  # based on win_pct, ties possible
    # tie-breaker stuff
    seed_tb_crit   = JSONField(null=True)     # stats criteria used to compute final rank
    seed_tb_data   = JSONField(null=True)     # raw data for reference
    player_rank    = IntegerField(null=True)  # stack-ranked, no ties
    player_rank_adj = IntegerField(null=True) # partner picking determination overrides
    # partner picks
    partner        = ForeignKeyField('self', field='player_num', column_name='partner_num',
                                     null=True)
    partner2       = ForeignKeyField('self', field='player_num', column_name='partner2_num',
                                     null=True)
    picked_by      = ForeignKeyField('self', field='player_num', column_name='picked_by_num',
                                     null=True)
    team           = DeferredForeignKey('Team', null=True)

    class Meta:
        indexes = (
            (('last_name', 'first_name'), True),
        )

    @classmethod
    def get_player_map(cls, join_partners: bool = False, by_rank: bool = False) -> dict[int, Self]:
        """Return dict of all players, indexed by player_num.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.PLAYER_NUMS:
            raise LogicError("player_nums not yet assigned")

        player_map = {}
        if join_partners:
            Partner = cls.alias()
            Partner2 = cls.alias()
            query = (cls
                     .select(cls, Partner, Partner2)
                     .left_outer_join(Partner, on=cls.partner)
                     .switch()
                     .left_outer_join(Partner2, on=cls.partner2))
        else:
            query = cls.select()
        if by_rank:
            query = query.order_by(cls.player_rank.asc(nulls='last'))
        for p in query:
            player_map[p.player_num] = p
        return player_map

    @classmethod
    def clear_player_nums(cls, ids: list[int] = None) -> int:
        """Delete player_num values for all rows (or specified IDs); return number of
        records updated.
        """
        if ids is not None:
            raise ImplementationError("list of IDs not yet supported")
        upd = Player.update(player_num=None)
        res = upd.execute()
        return res

    @classmethod
    def nums_used(cls, player: Self = None) -> Iterator[int]:
        """Return generator for player_nums currently assigned.  Do not include the
        specified player, if passed in.
        """
        query = cls.select(fn.group_concat(cls.player_num))
        if player:
            query = query.where(cls.id != player.id)
        num_str = query.scalar()
        if not num_str:
            return iter(())
        elif isinstance(num_str, int):
            return iter((num_str,))
        return (int(n) for n in num_str.split(','))

    @classmethod
    def nums_avail(cls, player: Self = None) -> list[int]:
        """Return sorted list of available player_nums.  Include the player_num for the
        specified player, if passed in.
        """
        tourn = TournInfo.get()
        all_nums = range(1, tourn.players + 1)
        return sorted(set(all_nums) - set(cls.nums_used(player)))

    @classmethod
    def clear_partner_picks(cls, ids: list[int] = None) -> int:
        """Delete partner_picks for all rows (or specified IDs); return number of records
        updated.
        """
        if ids is not None:
            raise ImplementationError("list of IDs not yet supported")
        upd = Player.update(partner=None, partner2=None, picked_by=None)
        res = upd.execute()
        return res

    @classmethod
    def available_players(cls) -> list[Self]:
        """Return list of available players, sorted by player_rank.
        """
        pl_iter = cls.iter_players(by_rank=True)
        return list(filter(lambda x: x.available, pl_iter))

    @classmethod
    def iter_players(cls, by_rank: bool = False, no_nums: bool = False) -> Iterator[Self]:
        """Iterator for players (wrap ORM details).
        """
        query = cls.select()
        if no_nums:
            query = query.where(cls.player_num.is_null(True))
        if by_rank:
            query = query.order_by(cls.player_rank.asc(nulls='last'))
        for p in query:
            yield p

    @property
    def name(self) -> str:
        """Alias/shortcut for nick_name (reads only)
        """
        return self.nick_name

    @property
    def champ(self) -> str | None:
        """For UI support ('y' or empty)
        """
        return 'y' if self.reigning_champ else None

    @property
    def available(self) -> str | None:
        """For partner picking UI; returns 'y' or None.  Note that this return value
        evaluates correctly as a boolean.
        """
        return 'y' if not (self.partner or self.picked_by) else None

    def get_game_stats(self, opps: list[Self] = None) -> dict:
        """Get stats for player's games (all, or versus specified opponents)
        """
        stat_keys = ('games', 'wins', 'team_pts', 'opp_pts')
        query = (PlayerGame
                 .select(fn.count(PlayerGame.id),
                         fn.sum(PlayerGame.is_winner),
                         fn.sum(PlayerGame.team_pts),
                         fn.sum(PlayerGame.opp_pts))
                 .where(PlayerGame.player == self))
        if opps:
            # NOTE: since we are not able to declare `opponents` with any kind of foreign
            # key declaration, we have to explicitly extract the right comparison keys
            # from the `opps` list
            opps_nums = [pl.player_num for pl in opps]
            query = query.where((PlayerGame.opponents.extract_text('0').in_(opps_nums)) |
                                (PlayerGame.opponents.extract_text('1').in_(opps_nums)))
        return dict(zip(stat_keys, query[0].__data__.values()))

    def pick_partners(self, partner: Self, partner2: Self = None) -> None:
        """Assign a partner to the current player (and possibly a second partner in the
        case of THM teams).  This call also sets the back-reference from the partner(s) to
        the playing picking.
        """
        if DEBUG:
            log.debug(f"player: {self.player_num} ({self.name})")
            log.debug(f"  - picks partner {partner.player_num} ({partner.name})")
        assert self.partner is None
        assert partner.picked_by is None
        self.partner = partner
        partner.picked_by = self

        if partner2:
            if DEBUG:
                log.debug(f"  - picks partner {partner2.player_num} ({partner2.name})")
            assert self.partner2 is None
            assert partner2.picked_by is None
            self.partner2 = partner2
            partner2.picked_by = self

    def save(self, *args, **kwargs):
        """Ensure that nick_name is not null, since it is used as the display name in
        brackets (defaults to last_name if not otherwise specified).  If `cascade=True` is
        specified, we propagate the save to partner(s), if dirty (e.g. can be used after
        pick_partners() is called).
        """
        if 'nick_name' in self._dirty:
            if not self.nick_name:
                self.nick_name = self.last_name
        if 'player_num' in self._dirty and self.player_num is not None:
            tourn = TournInfo.get()
            if self.player_num < 1 or self.player_num > tourn.players:
                raise ValueError(f"Player Num must be between 1 and {tourn.players}")
        # don't cascade by default (generates unnecessary lazy_load queries)
        if kwargs.pop('cascade', False):
            if self.partner and self.partner._dirty:
                self.partner.save()
                if self.partner2 and self.partner2._dirty:
                    self.partner2.save()
        return super().save(*args, **kwargs)

    def login(self, password: str) -> bool:
        """See `EuchmgrUser` (in security.py).

        Also see note about logging of clear password in `AdminUser.login`.
        """
        if password and not isinstance(password, str):
            log.info(f"login denied ({self.name}): invalid pw type {type(password)} "
                     f"('{password}')")
            raise AuthenticationError("Bad password specified")

        tourn = TournInfo.get()
        pw_hash = self.pw_hash or tourn.dflt_pw_hash
        if pw_hash:
            if not check_password_hash(pw_hash, password):
                log.info(f"login failed ({self.name}): bad password ('{password}')")
                raise AuthenticationError("Bad password specified")
        elif password:
            # give no outbound indication that password is not needed
            log.info(f"login failed ({self.name}): bad password ('{password}')")
            raise AuthenticationError("Bad password specified")

        login_user(self)
        log.info(f"login successful ({self.name})")
        return True

    def logout(self) -> bool:
        """See `EuchmgrUser` (in security.py).
        """
        assert current_user == self
        logout_user()
        return True

    def setpass(self, password: str) -> None:
        """See `EuchmgrUser` (in security.py).
        """
        # TODO: enforce password policy (length, diversity, etc.) here!!!
        pw_exists = bool(self.pw_hash)
        self.pw_hash = generate_password_hash(password)
        self.save()
        save = "changed" if pw_exists else "saved"
        log.info(f"password {saved} for user '{self.name}'")

############
# SeedGame #
############

class SeedGame(BaseModel):
    """
    """
    # required info
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # sd-{rnd}-{tbl}
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num',
                                     null=True)
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    player4        = ForeignKeyField(Player, field='player_num', column_name='player4_num',
                                     null=True)
    team1_name     = TextField(null=True)     # player1_name / player2_name
    team2_name     = TextField(null=True)     # player3_name / player4_name
    bye_players    = TextField(null=True)     # player1 / ...
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        query = cls.select()
        if not include_byes:
            query = query.where(cls.table_num.is_null(False))
        for t in query:
            yield t

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  It is no longer required
        that score updates come through here (since denorms are now managed elsewhere),
        but there is a little bit of integrity checking here that is slightly useful
        """
        if self.winner:
            raise RuntimeError("Completed game score cannot be overwritten")
        if not (0 <= (team1_pts or 0) <= GAME_PTS and 0 <= (team2_pts or 0) <= GAME_PTS):
            raise RuntimeError(f"Invalid score specified (must be between 0 and {GAME_PTS} points")

        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

    def update_player_stats(self) -> int:
        """Update stats for all players involved in the game; returns number of records
        updated.  Called by front-end after the game is complete (i.e. winner determined).
        There is no need to support partial-game stats.
        """
        players = [self.player1, self.player2, self.player3, self.player4]
        team_scores = [self.team1_pts, self.team2_pts]

        upd = 0
        for pl_idx, player in enumerate(players):
            tm_idx   = pl_idx // 2
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            player.seed_wins        += int(team_pts > opp_pts)
            player.seed_losses      += int(team_pts < opp_pts)
            player.seed_pts_for     += team_pts
            player.seed_pts_against += opp_pts

            ngames = player.seed_wins + player.seed_losses
            totpts = player.seed_pts_for + player.seed_pts_against
            player.seed_win_pct = rnd_pct(player.seed_wins / ngames)
            player.seed_pts_pct = rnd_pct(player.seed_pts_for / totpts)
            upd += player.save()

        return upd

    def insert_player_games(self) -> int:
        """Insert a record into the PlayerGame denorm for all players involved in the
        game; returns number of records inserted.  Called by front-end after the game is
        complete (i.e. winner determined)
        """
        bracket = Bracket.SEED
        players = [self.player1, self.player2, self.player3, self.player4]
        if self.table_num is None:
            assert self.bye_players is not None
            assert players[0] is not None
            assert players[-1] is None
            byes = list(filter(None, players))
            for player in byes:
                pg_info = {'bracket'   : bracket,
                           'round_num' : self.round_num,
                           'game_label': self.label,
                           'player'    : player,
                           'is_bye'    : True}
                pl_game = PlayerGame.create(**pg_info)
            return len(byes)

        partners = [players[1], players[0], players[3], players[2]]
        opps_tups = [(players[2], players[3]), (players[0], players[1])]
        team_scores = [self.team1_pts, self.team2_pts]

        pl_games = []
        for pl_idx, player in enumerate(players):
            tm_idx   = pl_idx // 2
            op_idx   = tm_idx ^ 0x01
            partner  = partners[pl_idx]
            opps_tup = opps_tups[tm_idx]
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            pg_info = {'bracket'      : bracket,
                       'round_num'    : self.round_num,
                       'game_label'   : self.label,
                       'player'       : player,
                       'partners'     : [partner.player_num],
                       'opponents'    : [p.player_num for p in opps_tup],
                       'partner_names': [partner.name],
                       'opp_names'    : [p.name for p in opps_tup],
                       'team_pts'     : team_pts,
                       'opp_pts'      : opp_pts,
                       'is_winner'    : team_pts > opp_pts}
            pl_game = PlayerGame.create(**pg_info)
            pl_games.append(pl_game)

        return len(pl_games)

    def save(self, *args, **kwargs):
        """Determine (and set) winner if game is complete
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in (self.team1_pts, self.team2_pts):
                if self.team1_pts >= GAME_PTS:
                    if self.team2_pts >= GAME_PTS:
                        raise RuntimeError(f"Only one team can score game-winning points ({GAME_PTS})")
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

########
# Team #
########

class Team(BaseModel):
    """
    """
    # required info
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num')
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    is_thm         = BooleanField(default=False)
    team_name      = TextField(unique=True)
    avg_player_rank = FloatField()
    top_player_rank = IntegerField()
    # tournament bracket
    team_seed      = IntegerField(unique=True, null=True)  # 1-based, based on player seeds
    div_num        = IntegerField(null=True)
    div_seed       = IntegerField(null=True)
    # tournament play
    tourn_wins     = IntegerField(default=0)
    tourn_losses   = IntegerField(default=0)
    tourn_win_pct  = FloatField(null=True)
    tourn_pts_for  = IntegerField(default=0)
    tourn_pts_against = IntegerField(default=0)
    tourn_pts_pct  = FloatField(null=True)
    tourn_pos      = IntegerField(null=True)  # based on win_pct, ties possible
    tourn_tb_crit  = JSONField(null=True)     # stats criteria used to compute rank
    tourn_tb_data  = JSONField(null=True)     # raw data for reference
    tourn_rank     = IntegerField(null=True)  # stack-ranked, no ties
    tourn_rank_adj = IntegerField(null=True)  # manual overrides
    div_pos        = IntegerField(null=True)  # based on win_pct, ties possible
    div_tb_crit    = JSONField(null=True)     # stats criteria used to compute rank
    div_tb_data    = JSONField(null=True)     # raw data for reference
    div_rank       = IntegerField(null=True)  # stack-ranked, no ties
    div_rank_adj   = IntegerField(null=True)  # manual overrides
    # playoff play
    playoff_match_wins = IntegerField(default=0)
    playoff_match_losses = IntegerField(default=0)
    playoff_wins   = IntegerField(default=0)
    playoff_losses = IntegerField(default=0)
    playoff_win_pct = FloatField(null=True)
    playoff_pts_for = IntegerField(default=0)
    playoff_pts_against = IntegerField(default=0)
    playoff_pts_pct = FloatField(null=True)
    playoff_rank   = IntegerField(null=True)  # final four teams only
    # final rankings
    final_rank     = IntegerField(null=True)  # stack-ranked, no ties
    final_rank_adj = IntegerField(null=True)  # manual overrides

    class Meta:
        indexes = (
            (('div_num', 'div_seed'), True),
        )

    @classmethod
    def iter_teams(cls, div: int = None, by_rank: bool = False) -> Iterator[Self]:
        """Iterator for teams (wrap ORM details).
        """
        query = cls.select()
        if div:
            query = query.where(cls.div_num == div)
            if by_rank:
                query = query.order_by(cls.div_rank.asc(nulls='last'))
        elif by_rank:
            query = query.order_by(cls.tourn_rank.asc(nulls='last'))
        for t in query:
            yield t

    @classmethod
    def iter_playoff_teams(cls, by_rank: bool = False) -> Iterator[Self]:
        """Iterator for playoff teams (wrap ORM details).
        """
        query = cls.select().where(cls.div_rank.in_([1, 2]))
        if by_rank:
            query = query.order_by(cls.playoff_rank.asc(nulls='last'), cls.tourn_rank.asc())
        for t in query:
            yield t

    @classmethod
    def iter_finals_teams(cls, by_rank: bool = False) -> Iterator[Self]:
        """Iterator for playoff teams (wrap ORM details).
        """
        query = cls.select().where(cls.playoff_match_wins > 0)
        if by_rank:
            query = query.order_by(cls.playoff_rank.asc())
        for t in query:
            yield t

    @classmethod
    def ident_div_tbs(cls, div_num: int, div_pos: int) -> list[list[Self]]:
        """Report teams with identical tie-break criteria for a divisional cohort
        (identical overall win percentage)
        """
        tbs = []
        query = (Team
                 .select(Team.div_tb_crit,
                         fn.group_concat(Team.id))
                 .where(Team.div_num == div_num,
                        Team.div_pos == div_pos,
                        Team.team_seed.is_null(False))
                 .group_by(Team.div_tb_crit)
                 .having(fn.count() > 1))
        for grp in query:
            ids: list[str] = grp.__data__['id'].split(',')
            teams: list[Team] = [Team.get(int(x)) for x in ids]
            tbs.append(teams)
        return tbs

    @property
    def is_champ(self) -> bool:
        """Note that the property (i.e. return) value is different than Player.champ
        """
        assert self.player2.champ == self.player1.champ
        if self.player3:
            assert self.player3.champ == self.player1.champ
        return bool(self.player1.champ)

    @property
    def playoff_team(self) -> bool:
        """Return true if a playoff team.  `None` returned if called before playoff teams
        have been determined.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.TOURN_RANKS:
            return None
        return self.div_rank in (1, 2)

    @property
    def finals_team(self) -> bool:
        """Return true if team is in the playoff finals round.  `None` returned if called
        before finals teams have been determined.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEMIS_RANKS:
            return None
        return self.playoff_match_wins > 0

    def get_wins(self, opps: list[Self]) -> list[BaseModel]:
        """Get TeamGame records for all wins versus specified opponents.
        """
        Opponent = Team.alias()
        query = (TeamGame
                 .select(TeamGame, Opponent)
                 .left_outer_join(Opponent, on=TeamGame.opponent)
                 .where(TeamGame.team == self,
                        TeamGame.opponent.in_(opps),
                        TeamGame.is_winner == True))
        return list(query)

    def get_game_stats(self, opps: list[Self] = None) -> dict:
        """Get stats for team's games (all, or versus specified opponents)
        """
        stat_keys = ('games', 'wins', 'team_pts', 'opp_pts')
        query = (TeamGame
                 .select(fn.count(TeamGame.id),
                         fn.sum(TeamGame.is_winner),
                         fn.sum(TeamGame.team_pts),
                         fn.sum(TeamGame.opp_pts))
                 .where(TeamGame.team == self))
        if opps:
            # note that `opponent` is defined as a foreign key, so the ORM will extract
            # the right column in `opps` for the `in_` operator
            query = query.where(TeamGame.opponent.in_(opps))
        return dict(zip(stat_keys, query[0].__data__.values()))

    def save_team_refs(self) -> None:
        """Add team reference to player members, and save.
        """
        self.player1.team = self
        self.player2.team = self
        self.player1.save()
        self.player2.save()
        if self.player3:
            self.player3.team = self
            self.player3.save()

#############
# TournGame #
#############

class TournGame(BaseModel):
    """
    """
    # required info
    div_num        = IntegerField()
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # rr-{div}-{rnd}-{tbl}
    team1          = ForeignKeyField(Team, column_name='team1_id')
    team2          = ForeignKeyField(Team, column_name='team2_id', null=True)
    team1_name     = TextField(null=True)     # denorm (null if team1 is bye_team)
    team2_name     = TextField(null=True)     # denorm
    bye_team       = TextField(null=True)
    team1_div_seed = IntegerField()
    team2_div_seed = IntegerField(null=True)
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('div_num', 'round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for tourn_games (wrap ORM details).
        """
        query = cls.select()
        if not include_byes:
            query = query.where(cls.table_num.is_null(False))
        for t in query:
            yield t

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  It is no longer required
        that score updates come through here (since denorms are now managed elsewhere),
        but there is a little bit of integrity checking here that is slightly useful
        """
        if self.winner:
            raise RuntimeError("Completed game score cannot be overwritten")
        if not (0 <= (team1_pts or 0) <= GAME_PTS and 0 <= (team2_pts or 0) <= GAME_PTS):
            raise RuntimeError(f"Invalid score specified (must be between 0 and {GAME_PTS} points")

        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

    def update_team_stats(self) -> int:
        """Update stats for teams involved in the game; returns number of records updated.
        Called by front-end after the game is complete (i.e. winner determined).  There is
        no need to support partial-game stats.
        """
        teams = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        upd = 0
        for tm_idx, team in enumerate(teams):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            team.tourn_wins        += int(team_pts > opp_pts)
            team.tourn_losses      += int(team_pts < opp_pts)
            team.tourn_pts_for     += team_pts
            team.tourn_pts_against += opp_pts

            ngames = team.tourn_wins + team.tourn_losses
            totpts = team.tourn_pts_for + team.tourn_pts_against
            team.tourn_win_pct = rnd_pct(team.tourn_wins / ngames)
            team.tourn_pts_pct = rnd_pct(team.tourn_pts_for / totpts)
            upd += team.save()

        return upd

    def insert_team_games(self) -> int:
        """Insert a record into the TeamGame denorm for teams involved in the game;
        returns number of records inserted.  Called by front-end after the game is
        complete (i.e. winner determined)
        """
        bracket = Bracket.TOURN
        if self.table_num is None:
            assert self.bye_team is not None
            assert self.team1 is not None
            assert self.team2 is None
            tg_info = {'bracket'   : bracket,
                       'round_num' : self.round_num,
                       'game_label': self.label,
                       'team'      : self.team1,
                       'is_bye'    : True}
            tm_game = TeamGame.create(**tg_info)
            return 1

        teams = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        tm_games = []
        for tm_idx, team in enumerate(teams):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            tg_info = {'bracket'   : bracket,
                       'round_num' : self.round_num,
                       'game_label': self.label,
                       'team'      : team,
                       'opponent'  : teams[op_idx],
                       'team_pts'  : team_pts,
                       'opp_pts'   : opp_pts,
                       'is_winner' : team_pts > opp_pts}
            tm_game = TeamGame.create(**tg_info)
            tm_games.append(tm_game)

        return len(tm_games)

    def save(self, *args, **kwargs):
        """Compute winner if both scores have been entered
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in (self.team1_pts, self.team2_pts):
                if self.team1_pts >= GAME_PTS:
                    if self.team2_pts >= GAME_PTS:
                        raise RuntimeError(f"Only one team can score game-winning points ({GAME_PTS})")
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

###############
# PlayoffGame #
###############

class PlayoffGame(BaseModel):
    """
    """
    # required info
    bracket        = TextField()              # "sf" or "fn"
    matchup_num    = IntegerField()
    round_num      = IntegerField()           # shown as "game" number
    label          = TextField(unique=True)   # {brckt}-{mtchup}-{rnd}
    team1          = ForeignKeyField(Team, column_name='team1_id')
    team2          = ForeignKeyField(Team, column_name='team2_id')
    team1_name     = TextField()              # denorm
    team2_name     = TextField()              # denorm
    team1_div_rank = IntegerField()
    team2_div_rank = IntegerField()
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('bracket', 'matchup_num', 'round_num'), True),
        )

    @classmethod
    def iter_games(cls, bracket: Bracket = None, by_matchup: bool = False) -> Iterator[Self]:
        """Iterator for playoff_games (wrap ORM details).
        """
        query = cls.select()
        if bracket:
            query = query.where(cls.bracket == bracket)
        if by_matchup:
            query = query.order_by(cls.bracket, cls.matchup_num, cls.round_num)
        for t in query:
            yield t

    @property
    def matchup_winner(self) -> Team | None:
        """Return name of winner (if any) for the current matchup.  This is currently
        hard-wired with the assumption of best 2-out-of-3 matchups (as with the rest of
        the playoff locic for now).
        """
        cls = self.__class__
        query = (cls
                 .select(cls.winner, fn.count(cls.id).alias('wins'))
                 .where(cls.bracket == self.bracket,
                        cls.matchup_num == self.matchup_num,
                        cls.winner.is_null(False))
                 .group_by(cls.winner)
                 .order_by(fn.count(cls.id).desc()))
        if not query or query[0].wins < 2:
            return None
        if query[0].wins > 2:
            raise DataError(f"More than 2 wins ({query[0].wins}) for '{query[0].winner}' "
                            f"in matchup {self.matchup_ident}")
        if query.count() > 1 and query[1].wins > 1:
            raise DataError(f"More than one winner for matchup {self.matchup_ident}")
        return self.team1 if query[0].winner == self.team1.team_name else self.team2

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  It is no longer required
        that score updates come through here (since denorms are now managed elsewhere),
        but there is a little bit of integrity checking here that is slightly useful
        """
        if self.winner:
            raise RuntimeError("Completed game score cannot be overwritten")
        if not (0 <= (team1_pts or 0) <= GAME_PTS and 0 <= (team2_pts or 0) <= GAME_PTS):
            raise RuntimeError(f"Invalid score specified (must be between 0 and {GAME_PTS} points")

        if self.matchup_winner:
            raise RuntimeError(f"Matchup already complete (winner '{self.matchup_winner.team_name}')")

        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

    def update_team_stats(self) -> int:
        """Update stats for teams involved in the game; returns number of records updated.
        Called by front-end after the game is complete (i.e. winner determined).  There is
        no need to support partial-game stats.
        """
        teams = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        upd = 0
        for tm_idx, team in enumerate(teams):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            team.playoff_wins        += int(team_pts > opp_pts)
            team.playoff_losses      += int(team_pts < opp_pts)
            team.playoff_pts_for     += team_pts
            team.playoff_pts_against += opp_pts

            if self.matchup_winner:
                if team == self.matchup_winner:
                    team.playoff_match_wins += 1
                else:
                    team.playoff_match_losses += 1

            ngames = team.playoff_wins + team.playoff_losses
            totpts = team.playoff_pts_for + team.playoff_pts_against
            team.playoff_win_pct = rnd_pct(team.playoff_wins / ngames)
            team.playoff_pts_pct = rnd_pct(team.playoff_pts_for / totpts)
            upd += team.save()

        return upd

    def save(self, *args, **kwargs):
        """Compute winner if both scores have been entered
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in (self.team1_pts, self.team2_pts):
                if self.team1_pts >= GAME_PTS:
                    if self.team2_pts >= GAME_PTS:
                        raise RuntimeError(f"Only one team can score game-winning points ({GAME_PTS})")
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

##############
# PlayerGame #
##############

class PlayerGame(BaseModel):
    """Denormalization of SeedGame (and possibly TournGame data), for use in computing
    stats, determining head-to-head match-ups, etc.
    """
    bracket        = TextField()            # "sd" (or "rr", etc. if tabulating for players)
    round_num      = IntegerField()
    game_label     = TextField()            # sd-{rnd}-{tbl}, rr-{div}-{rnd}-{tbl}, etc.
    player         = ForeignKeyField(Player, field='player_num', column_name='player_num')
    player_name    = TextField()            # automatic denorm
    partners       = JSONField(null=True)   # array of partner player_num(s)
    opponents      = JSONField(null=True)   # array of opposing player_nums
    partner_names  = JSONField(null=True)   # denorm
    opp_names      = JSONField(null=True)   # denorm
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'player'), True),
            (('game_label', 'player'), True)
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        query = cls.select()
        if not include_byes:
            query = query.where(cls.is_bye == False)
        for t in query:
            yield t

    def save(self, *args, **kwargs):
        """Set player name (denorm field) as player's nick name
        """
        if not self.player_name:
            self.player_name = self.player.name
        return super().save(*args, **kwargs)

############
# TeamGame #
############

class TeamGame(BaseModel):
    """Denormalization of TournGame data, for use in computing stats, determining
    head-to-head match-ups, etc.
    """
    bracket        = TextField()           # "rr", "sf", or "fn"
    round_num      = IntegerField()
    game_label     = TextField()           # rr-{div}-{rnd}-{tbl}, etc.
    team           = ForeignKeyField(Team)
    opponent       = ForeignKeyField(Team, column_name='opp_id', null=True)
    team_name      = TextField()
    opp_name       = TextField(null=True)  # or "bye"(?)
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'team'), True),
            (('game_label', 'team'), True)
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for tourn_games (wrap ORM details).
        """
        query = cls.select()
        if not include_byes:
            query = query.where(cls.is_bye == False)
        for t in query:
            yield t

    def save(self, *args, **kwargs):
        """Set team and opponane names (denorm fields)
        """
        if not self.team_name:
            self.team_name = self.team.team_name
        if self.opponent and not self.opp_name:
            self.opp_name = self.opponent.team_name
        return super().save(*args, **kwargs)

#############
# PostScore #
#############

class ScoreAction(StrEnum):
    SUBMIT  = "submit"
    ACCEPT  = "accept"
    CORRECT = "correct"
    IGNORE  = " (ignored)"
    DISCARD = " (discarded)"

class PostScore(BaseModel):
    """
    """
    bracket        = TextField()              # "sd", "rr", "sf", or "fn"
    game_label     = TextField()              # sd-{rnd}-{tbl}, rr-{div}-{rnd}-{tbl}, etc.
    post_action    = TextField()
    action_info    = TextField(null=True)
    team1_pts      = IntegerField()
    team2_pts      = IntegerField()
    posted_by      = ForeignKeyField(Player, field='player_num', column_name='posted_by_num')
    team_idx       = IntegerField()           # for `posted_by` (`0` - team1, `1` - team2)
    ref_score      = ForeignKeyField('self', null=True)
    do_push        = BooleanField(null=True)

    class Meta:
        indexes = (
            (('game_label', 'created_at'), False),
        )

    @classmethod
    def fetch_by_id(cls, id: int) -> Self:
        """Wrapper around `get_or_none`, but detect empty `id` arg (and also goot to hide
        ORM details).
        """
        if not id:
            return None
        return cls.get_or_none(id)

    @classmethod
    def get_posts(cls, label: str) -> list[Self]:
        """Return PostScore records for specified game label, in chronological order.
        """
        query = (cls
                 .select()
                 .where(cls.game_label == label)
                 .order_by(cls.id))
        return list(query)

    @classmethod
    def get_last(cls, label: str, include_accept: bool = False) -> Self:
        """Get most recent submitted score for specified game label.  Return `None` if no
        scores posted.
        """
        assert label
        actions = [ScoreAction.SUBMIT, ScoreAction.CORRECT]
        if include_accept:
            actions.append(ScoreAction.ACCEPT)
        query = (cls
                 .select()
                 .where(cls.game_label == label,
                        cls.post_action.in_(actions))
                 .order_by(cls.id.desc())
                 .limit(1))
        return query.get_or_none()

    def push_scores(self) -> None:
        """Push accepted scores to appropriate bracket.
        """
        assert self.do_push
        if self.bracket == Bracket.SEED:
            game = SeedGame.get(SeedGame.label == self.game_label)
            game.add_scores(self.team1_pts, self.team2_pts)
            game.save()
            if game.winner:
                game.update_player_stats()
                game.insert_player_games()
        elif self.bracket == Bracket.TOURN:
            game = TournGame.get(TournGame.label == self.game_label)
            game.add_scores(self.team1_pts, self.team2_pts)
            game.save()
            if game.winner:
                game.update_team_stats()
                game.insert_team_games()
        elif self.bracket in (Bracket.SEMIS, Bracket.FINALS):
            game = PlayoffGame.get(PlayoffGame.label == self.game_label)
            game.add_scores(self.team1_pts, self.team2_pts)
            game.save()
            if game.winner:
                game.update_team_stats()
                #game.insert_team_games()
        else:
            raise LogicError(f"Invalid bracket '{self.bracket}'")

#################
# schema_create #
#################

ALL_MODELS = [TournInfo, Player, SeedGame, Team, TournGame, PlayoffGame, PlayerGame,
              TeamGame, PostScore]

def schema_create(models: list[BaseModel | str] | str = None, force = False) -> None:
    """Create tables for specified models (list of objects or comma-separated list of
    names), or all models if no list is specified.
    """
    if models is None:
        models = ALL_MODELS
    elif isinstance(models, str):
        models = models.split(',')
    assert isinstance(models, list)
    if isinstance(models[0], str):
        models_new = []
        for model in models:
            if model not in globals():
                raise RuntimeError(f"Model {model} not imported")
            model_obj = globals()[model]
            if not issubclass(model_obj, BaseModel):
                raise RuntimeError(f"Model {model} must be subclass of `BaseModel`")
            models_new.append(model_obj)
        models = models_new

    if force:
        # we just drop all tables so we don't have to worry about integrity, cascading
        # deletes, legacy data, etc. (our version of `safe=False`)
        for model in reversed(models):
            model.drop_table()
    else:
        # the existenace of ANY of the specified tables disqualifies the entire request
        for model in models:
            if model.table_exists():
                table_name = model._meta.table_name
                raise OperationalError(f'table "{table_name}" already exists')

    for model in models:
        model.create_table(safe=False)
