# -*- coding: utf-8 -*-

from enum import IntEnum, StrEnum
from typing import ClassVar, Self, Iterator, NamedTuple
import re

from peewee import (TextField, IntegerField, BooleanField, FloatField, ForeignKeyField,
                    DeferredForeignKey, OperationalError, DoesNotExist, fn)
from playhouse.sqlite_ext import JSONField
from flask_login import current_user, login_user, logout_user
from werkzeug.security import generate_password_hash, check_password_hash

from core import DEBUG, log, ImplementationError, LogicError, DataError
from security import EuchmgrUser, AuthenticationError
from database import BaseModel

DFLT_SEED_ROUNDS  = 8
DFLT_TOURN_ROUNDS = 8
DFLT_DIVISIONS    = 2

GAME_PTS          = 10

class Bracket(StrEnum):
    SEED   = 'sd'
    TOURN  = 'rr'  # for "round robin"
    SEMIS  = 'sf'
    FINALS = 'fn'

BRACKET_NAME = {
    Bracket.SEED  : "Seeding",
    Bracket.TOURN : "Round Robin",
    Bracket.SEMIS : "Semifinals",
    Bracket.FINALS: "Finals",
}

# hard-wired floating point precision (depending on field type), helpful for neater
# display as well as equivalence determination (without additional rounding)
rnd_pct = lambda x: round(x, 5)
rnd_avg = lambda x: round(x, 2)

# stage values are chronologically sequenced
TournStage = IntEnum('TournStage',
                     ['TOURN_CREATE',    # 1
                      'PLAYER_ROSTER',
                      'PLAYER_NUMS',
                      'SEED_BRACKET',
                      'SEED_RESULTS',    # 5
                      'SEED_TABULATE',
                      'SEED_RANKS',
                      'PARTNER_PICK',
                      'TOURN_TEAMS',
                      'TEAM_SEEDS',      # 10
                      'TOURN_BRACKET',
                      'TOURN_RESULTS',
                      'TOURN_TABULATE',
                      'TOURN_RANKS',
                      'SEMIS_BRACKET',   # 15
                      'SEMIS_RESULTS',
                      'SEMIS_TABULATE',
                      'SEMIS_RANKS',
                      'FINALS_BRACKET',
                      'FINALS_RESULTS',  # 20
                      'FINALS_TABULATE',
                      'FINALS_RANKS'])

# represents virtual stages before and after TournStage entries
TOURN_INIT = 0
TOURN_FINAL = len(TournStage) + 1
ACTIVE_STAGES = range(TournStage.PLAYER_ROSTER, TOURN_FINAL)

class StageInfo(NamedTuple):
    """Behavior parameters and messages for tournament stages

    REVISIT(?): there is currently redundancy in the two boolean flags, but we may keep it
    this way for integrity checking
    """
    long_running: bool  # possible manual data entry/finalization in order to complete
    auto_advance: bool  # start next stage automatically upon completion
    start_msg:    str   # only needed if long_running
    compl_msg:    str   # not visible if auto_advance (though specified regardless)

# NOTE that we are being a little particular/pedantic about wording for messages here:
# - "seed" means assigned position within a bracket based on past performance
# - "seeding" means the seeding round process
# - "round robin" means the main tournament, not including playoffs
# - "playoffs" means the semi-final and final rounds of the tournament
# - "rank" or "ranking" means finish position after play is over
# - "position" means order on the scale of performance during play
# - "completed" means data entry of an activity (e.g. playing or picking) is done
# - "computed" or "tabulated" means something algorithmically generated by the program
# - "assigned" means the completion of a process that may be either manual or automated
#
STAGE_DATA = [
    StageInfo(False, False, None,                            "New tournament"),
    StageInfo(True,  True,  "Creating player roster",        "Player roster created"),
    StageInfo(True,  False, "Assigning player nums",         "Player nums assigned"),
    StageInfo(False, True,  "Generate seeding bracket",      "Seeding bracket created"),
    StageInfo(True , False, "Seeding round active",          "Seeding results completed"),
    StageInfo(False, False, "Tabulate seeding results",      "Seeding results tabulated"),
    StageInfo(False, True,  None,                            "Seeding rankings computed"),
    StageInfo(True,  False, "Picking partners",              "Partner picks completed"),
    StageInfo(False, False, "Generate round robin brackets", "Round robin teams created"),
    StageInfo(False, False, None,                            "Round robin team seeds computed"),
    StageInfo(False, True,  None,                            "Round robin brackets created"),
    StageInfo(True,  False, "Round robin play active",       "Round robin results completed"),
    StageInfo(False, False, "Tabulate round robin results",  "Round robin results tabulated"),
    StageInfo(False, False, None,                            "Team rankings computed"),
    StageInfo(False, True,  None,                            "Semifinals brackets created"),
    StageInfo(True,  False, "Semifinals play active",        "Semifinals results completed"),
    StageInfo(False, False, "Tabulate semifinals results",   "Semifinals results tabulated"),
    StageInfo(False, False, None,                            "Semifinals rankings computed"),
    StageInfo(False, True,  None,                            "Finals brackets created"),
    StageInfo(True,  False, "Finals play active",            "Finals results completed"),
    StageInfo(False, False, "Tabulate finals results",       "Finals results tabulated"),
    StageInfo(False, False, None,                            "Finals rankings computed")
]

assert len(STAGE_DATA) == len(TournStage)  # not ensured by zip
StageData = dict(zip(TournStage, STAGE_DATA))

def clear_schema_cache() -> None:
    """This needs to be called every time we switch (or reset) databases.

    FIX: this is currently only called from `conftest.py`, but also needs to be
    incorporated into the database management logic in `server.py`!!!
    """
    TournInfo.clear_cache()
    Player.clear_cache()
    Team.clear_cache()

#############
# TournInfo #
#############

class TournInfo(BaseModel):
    """High-level tournament information.  There is only one instance per database (since
    the database encapsulates the entire data for a single tournament).
    """
    name           = TextField(unique=True)
    dates          = TextField(null=True)
    venue          = TextField(null=True)
    stage_start    = IntegerField()
    stage_compl    = IntegerField()
    cur_stage      = TextField()
    next_action    = TextField(null=True)
    players        = IntegerField(null=True)
    teams          = IntegerField(null=True)
    thm_teams      = IntegerField(null=True)
    seed_rounds    = IntegerField(default=DFLT_SEED_ROUNDS)
    tourn_rounds   = IntegerField(default=DFLT_TOURN_ROUNDS)
    divisions      = IntegerField(default=DFLT_DIVISIONS)
    dflt_pw_hash   = TextField(null=True)  # initial/default pw_hash for players

    # class variables
    inst: ClassVar[Self] = None  # singleton instance

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above)
        """
        cls.inst = None

    @classmethod
    def get(cls, requery: bool = False) -> Self:
        """Return cached singleton instance (purposefully shadows more general base class
        method).
        """
        if cls.inst is None or requery:
            res = [t for t in cls.select().limit(2).iterator()]
            assert len(res) == 1  # fails if not initialized, or unexpected multiple records
            cls.inst = res[0]
        return cls.inst

    @classmethod
    def mark_stage_start(cls, stage: TournStage) -> None:
        """Mark the start of the specified stage (and save) for the cached singleton
        """
        tourn = TournInfo.get()
        tourn.start_stage(stage)

    @classmethod
    def mark_stage_complete(cls, stage: TournStage) -> None:
        """Mark the completion of the specified stage (and save) for the cached singleton
        """
        tourn = TournInfo.get()
        tourn.complete_stage(stage)

    def save(self, *args, **kwargs):
        """Manage stage changes and associated message text
        """
        if 'stage_compl' in self._dirty:
            stage_data = StageData[self.stage_compl]

            if self.stage_start != self.stage_compl:
                assert not self.stage_start or self.stage_start < self.stage_compl
                # set stage_start implicitly (e.g. for for short operations)
                self.stage_start = self.stage_compl

            if stage_data.auto_advance:
                # this may overwrite the update above, but we leave things like this for
                # the associated integrity checking
                stage_next = self.stage_compl + 1
                self.stage_start = stage_next
                self.cur_stage = StageData[stage_next].start_msg
                self.next_action = StageData[stage_next].compl_msg
            else:
                self.cur_stage = stage_data.compl_msg
                stage_next = self.stage_compl + 1
                if stage_next < len(StageData):
                    self.next_action = StageData[stage_next].start_msg
                else:
                    self.next_action = None
            # TODO: should also log this information!!!

        if self.id is None:
            cls = type(self)
            cls.inst = None
        return super().save(*args, **kwargs)

    def start_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the start of the specified stage (and save, by default)
        """
        self.stage_start = stage
        if auto_save:
            self.save()

    def complete_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the completion of the specified stage (and save, by default)
        """
        self.stage_compl = stage
        if auto_save:
            self.save()

    def seeding_done(self) -> bool:
        """Official way to check if seeding is complete (scores validated and final player
        rankings computed)
        """
        return self.stage_compl >= TournStage.SEED_RANKS

    def partner_picks_done(self) -> bool:
        """Official way to check if partner picking is complete (all picks made and teams
        determined)
        """
        return self.stage_compl >= TournStage.TOURN_TEAMS

    def round_robin_done(self) -> bool:
        """Official way to check if round robin is complete (scores validated and final
        team rankings computed)
        """
        return self.stage_compl >= TournStage.TOURN_RANKS

##########
# Player #
##########

EMPTY_PLYR_STATS = {
    'seed_wins'       : None,
    'seed_losses'     : None,
    'seed_pts_for'    : None,
    'seed_pts_against': None
}

class Player(BaseModel, EuchmgrUser):
    """Represents a player in the tournament, as well as a mobile (i.e. non-admin) user of
    the app.
    """
    # identifying info
    first_name     = TextField()
    last_name      = TextField()
    nick_name      = TextField(unique=True)  # serves as player_name (defaults to last_name)
    reigning_champ = BooleanField(default=False)
    player_num     = IntegerField(unique=True, null=True)  # 1-based, must be contiguous
    pw_hash        = TextField(null=True)    # default pw_hash (in TournInfo) is used, if null
    # seeding round
    seed_wins      = IntegerField(default=0)
    seed_losses    = IntegerField(default=0)
    seed_win_pct   = FloatField(null=True)
    seed_pts_for   = IntegerField(default=0)
    seed_pts_against = IntegerField(default=0)
    seed_pts_pct   = FloatField(null=True)
    player_pos     = IntegerField(null=True)  # based on win_pct, ties possible
    # tie-breaker stuff
    seed_tb_crit   = JSONField(null=True)     # stats criteria used to compute final rank
    seed_tb_data   = JSONField(null=True)     # raw data for reference
    player_rank    = IntegerField(null=True)  # stack-ranked, no ties
    player_rank_adj = IntegerField(null=True) # partner picking determination overrides
    # partner picks
    partner        = ForeignKeyField('self', field='player_num', column_name='partner_num',
                                     null=True)
    partner2       = ForeignKeyField('self', field='player_num', column_name='partner2_num',
                                     null=True)
    picked_by      = ForeignKeyField('self', field='player_num', column_name='picked_by_num',
                                     null=True)
    team           = DeferredForeignKey('Team', null=True)

    # class variables
    player_map: ClassVar[dict[int, Self]] = None  # indexed by player_num

    class Meta:
        indexes = (
            (('last_name', 'first_name'), True),
        )

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above)
        """
        cls.player_map = None

    @classmethod
    def get_player_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all players, indexed by player_num
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.PLAYER_NUMS:
            raise LogicError("player_nums not yet assigned")

        if cls.player_map and not requery:
            return cls.player_map

        cls.player_map = {}
        for p in cls.select().iterator():
            cls.player_map[p.player_num] = p
        return cls.player_map

    @classmethod
    def clear_player_nums(cls, ids: list[int] = None) -> int:
        """Delete player_num values for all rows (or specified IDs); return number of
        records updated.  Also refreshes (or clears) the cached player map.
        """
        if ids is not None:
            raise ImplementationError("list of IDs not yet supported")
        upd = Player.update(player_num=None)
        res = upd.execute()
        cls.player_map = None
        return res

    @classmethod
    def nums_used(cls, player: Self = None) -> Iterator[int]:
        """Return generator for player_nums currently assigned.  Do not include the
        specified player, if passed in.
        """
        query = cls.select(fn.group_concat(cls.player_num))
        if player:
            query = query.where(cls.id != player.id)
        num_str = query.scalar()
        if not num_str:
            return iter(())
        elif isinstance(num_str, int):
            return iter((num_str,))
        return (int(n) for n in num_str.split(','))

    @classmethod
    def nums_avail(cls, player: Self = None) -> list[int]:
        """Return sorted list of available player_nums.  Include the player_num for the
        specified player, if passed in.
        """
        tourn = TournInfo.get()
        all_nums = range(1, tourn.players + 1)
        return sorted(set(all_nums) - set(cls.nums_used(player)))

    @classmethod
    def clear_partner_picks(cls, ids: list[int] = None) -> int:
        """Delete partner_picks for all rows (or specified IDs); return number of records
        updated.  Also refreshes (or clears) the cached player map.
        """
        if ids is not None:
            raise ImplementationError("list of IDs not yet supported")
        upd = Player.update(partner=None, partner2=None, picked_by=None)
        res = upd.execute()
        cls.player_map = None
        return res

    @classmethod
    def available_players(cls, requery: bool = False) -> list[Self]:
        """Return list of available players, sorted by player_rank.  Note that this goes
        against the cached player map, so can be reused locally (e.g. in a loop without
        requerying when faking partner picks).
        """
        pl_list = cls.get_player_map(requery).values()
        avail = filter(lambda x: x.available, pl_list)
        return sorted(avail, key=lambda x: x.player_rank)

    @classmethod
    def get_player(cls, player_num: int) -> Self:
        """Return player by player_num (from cached map)
        """
        pl_map = cls.get_player_map()
        return pl_map[player_num]

    @classmethod
    def fetch_by_rank(cls, player_rank: int) -> Self:
        """Return player by player_rank (always retrieved from database), or `None` if not
        found
        """
        return cls.get_or_none(cls.player_rank == player_rank)

    @classmethod
    def fetch_by_name(cls, name: str) -> Self:
        """Return player by name (same as nick_name), or `None` if not found.  Always
        retrieved from database (not from local cache).
        """
        return cls.get_or_none(cls.nick_name == name)

    @classmethod
    def find_by_name_pfx(cls, name_pfx: str) -> Iterator[Self]:
        """Iterator returning players matching the specified (nick) name prefix
        """
        query = cls.select().where(cls.nick_name.startswith(name_pfx))
        for p in query.iterator():
            yield p

    @classmethod
    def iter_players(cls, by_rank: bool = False, no_nums: bool = False) -> Iterator[Self]:
        """Iterator for players (wrap ORM details).  Note that this also clears out local
        cache, if populated.
        """
        if cls.player_map:
            cls.player_map = None

        query = cls.select()
        if no_nums:
            query = query.where(cls.player_num.is_null(True))
        if by_rank:
            query = query.order_by(cls.player_rank.asc(nulls='last'))
        for p in query.iterator():
            yield p

    @property
    def name(self) -> str:
        """Alias/shortcut for nick_name
        """
        return self.nick_name

    @property
    def full_name(self) -> str:
        """For UI support (one field instead of two)
        """
        return self.first_name + ' ' + self.last_name

    @property
    def display_name(self) -> str:
        """For UI support (especially if/when sorting by last name)
        """
        friendly = self.nick_name if self.nick_name != self.last_name else self.first_name
        return f"{self.last_name} ({friendly})"

    @property
    def player_tag(self) -> str:
        """Combination of player_num and nick_name with embedded HTML annotation (used for
        bracket and scores/results displays)
        """
        return f"<b>{self.player_num}</b>&nbsp;&nbsp;<u>{self.nick_name}</u>"

    @property
    def player_data(self) -> dict:
        """Return player data as a dict, removing distracting default values if not relevant
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEED_BRACKET:
            return self.__data__ | EMPTY_PLYR_STATS
        return self.__data__

    @property
    def champ(self) -> str | None:
        """For UI support ('y' or empty)
        """
        return 'y' if self.reigning_champ else None

    @property
    def available(self) -> str | None:
        """For partner picking UI; returns 'y' or None.  Note that this return value
        evaluates correctly as a boolean.
        """
        return 'y' if not (self.partner or self.picked_by) else None

    @property
    def seed_ident(self) -> str:
        """Player "name (rank)", for partner picking UI
        """
        return f"{self.nick_name} ({self.player_rank})"

    @property
    def picks_info(self) -> str | None:
        """For partner picking UI
        """
        pt_info = None
        if self.partner:
            pt_info = self.partner.seed_ident
            if self.partner2:
                pt_info += f", {self.partner2.seed_ident}"
        return pt_info

    @property
    def picks_info2(self) -> str | None:
        """For partner picking UI
        """
        pt_info = None
        if self.partner:
            pt_info = self.partner.seed_ident
            if self.partner2:
                pt_info += f"<br>{self.partner2.seed_ident}"
        return pt_info

    @property
    def picked_by_info(self) -> str | None:
        """For partner picking UI
        """
        return self.picked_by.seed_ident if self.picked_by else None

    @property
    def player_pos_str(self) -> str | None:
        """Same as player_pos, except annotated if tied with others
        """
        if self.player_pos is None:
            return None
        elif not self.seed_tb_crit:
            return str(self.player_pos)
        return f"{self.player_pos}*"

    @property
    def player_rank_final(self, annotated: bool = False) -> int | str:
        """The official value for player ranking (defaults to player_rank, with override
        from player_rank_adj).  String value is returned if `annotated` is specified as
        True, with override indicated (if present).
        """
        if annotated:
            if self.player_rank_adj:
                return f"{self.player_rank_adj} ({self.player_rank})"
            else:
                return str(self.player_rank)

        return self.player_rank_adj or self.player_rank

    @property
    def current_game(self) -> BaseModel:
        """Return current SeedGame for player (only if seeding stage is active)
        """
        pg = (PlayerGame
              .select(fn.max(PlayerGame.round_num))
              .where(PlayerGame.player == self,
                     PlayerGame.is_bye == False)
              .get())
        last_round = pg.round_num or 0
        cg = (SeedGame
              .select()
              .where((SeedGame.player1 == self) |
                     (SeedGame.player2 == self) |
                     (SeedGame.player3 == self) |
                     (SeedGame.player4 == self))
              .where(SeedGame.table_num.is_null(False),
                     SeedGame.round_num > last_round)
              .order_by(SeedGame.round_num))
        return cg[0] if len(cg) > 0 else None

    def get_games(self, all_games: bool = False) -> list[BaseModel]:
        """Get completed SeedGame records (including possible byes up to the current round
        for the stage).
        """
        cur_round = SeedGame.current_round()
        if cur_round == 0:
            return None  # as distinct from [], e.g. game 1 in progress
        query = (SeedGame
                 .select()
                 .where((SeedGame.player1 == self) |
                        (SeedGame.player2 == self) |
                        (SeedGame.player3 == self) |
                        (SeedGame.player4 == self))
                 .order_by(SeedGame.round_num))
        if cur_round != -1 and not all_games:
            query = query.where(SeedGame.round_num <= cur_round)
        return list(query)

    def get_opps_games(self, opps: list[Self]) -> list[BaseModel]:
        """Get SeedGame records for all games versus specified opponents
        """
        query = (SeedGame
                 .select()
                 .join(PlayerGame, on=(PlayerGame.game_label == SeedGame.label))
                 .where(PlayerGame.player == self))
        # see NOTE below (in get_game_stats())
        opps_nums = [pl.player_num for pl in opps]
        query = query.where((PlayerGame.opponents.extract_text('0').in_(opps_nums)) |
                            (PlayerGame.opponents.extract_text('1').in_(opps_nums)))
        return list(query)

    def get_game_stats(self, opps: list[Self] = None) -> dict:
        """Get stats for player's games (all, or versus specified opponents)
        """
        stat_keys = ('games', 'wins', 'team_pts', 'opp_pts')
        query = (PlayerGame
                 .select(fn.count(PlayerGame.id),
                         fn.sum(PlayerGame.is_winner),
                         fn.sum(PlayerGame.team_pts),
                         fn.sum(PlayerGame.opp_pts))
                 .where(PlayerGame.player == self))
        if opps:
            # NOTE: since we are not able to declare `opponents` with any kind of foreign
            # key declaration, we have to explicitly extract the right comparison keys
            # from the `opps` list
            opps_nums = [pl.player_num for pl in opps]
            query = query.where((PlayerGame.opponents.extract_text('0').in_(opps_nums)) |
                                (PlayerGame.opponents.extract_text('1').in_(opps_nums)))
        return dict(zip(stat_keys, query[0].__data__.values()))

    def pick_partners(self, partner: Self, partner2: Self = None) -> None:
        """
        """
        if DEBUG:
            print(f"player: {self.player_num} ({self.nick_name})")
            print(f"  - picks partner {partner.player_num} ({partner.nick_name})")
        assert self.partner is None
        assert partner.picked_by is None
        self.partner = partner
        partner.picked_by = self

        if partner2:
            if DEBUG:
                print(f"  - picks partner {partner2.player_num} ({partner2.nick_name})")
            assert self.partner2 is None
            assert partner2.picked_by is None
            self.partner2 = partner2
            partner2.picked_by = self

    def save(self, *args, **kwargs):
        """Ensure that nick_name is not null, since it is used as the display name in
        brackets (defaults to last_name if not otherwise specified)
        """
        if 'nick_name' in self._dirty:
            if not self.nick_name:
                self.nick_name = self.last_name
        if 'player_num' in self._dirty and self.player_num is not None:
            tourn = TournInfo.get()
            if self.player_num < 1 or self.player_num > tourn.players:
                raise ValueError(f"Player Num must be between 1 and {tourn.players}")
        # cascade commit to partner(s), if dirty
        if self.partner and self.partner._dirty:
            self.partner.save()
            if self.partner2 and self.partner2._dirty:
                self.partner2.save()
        return super().save(*args, **kwargs)

    def login(self, password: str) -> bool:
        """See `EuchmgrUser` (in security.py).

        Also see note about logging of clear password in `AdminUser.login`.
        """
        if password and not isinstance(password, str):
            log.info(f"login denied ({self.name}): invalid pw type {type(password)} "
                     f"('{password}')")
            raise AuthenticationError("Bad password specified")

        tourn = TournInfo.get()
        pw_hash = self.pw_hash or tourn.dflt_pw_hash
        if pw_hash:
            if not check_password_hash(pw_hash, password):
                log.info(f"login failed ({self.name}): bad password ('{password}')")
                raise AuthenticationError("Bad password specified")
        elif password:
            # give no outbound indication that password is not needed
            log.info(f"login failed ({self.name}): bad password ('{password}')")
            raise AuthenticationError("Bad password specified")

        login_user(self)
        log.info(f"login successful ({self.name})")
        return True

    def logout(self) -> bool:
        """See `EuchmgrUser` (in security.py).
        """
        assert current_user == self
        logout_user()
        return True

    def setpass(self, password: str) -> None:
        """See `EuchmgrUser` (in security.py).
        """
        # TODO: enforce password policy (length, diversity, etc.) here!!!
        pw_exists = bool(self.pw_hash)
        self.pw_hash = generate_password_hash(password)
        self.save()
        save = "changed" if pw_exists else "saved"
        log.info(f"password {saved} for user '{self.name}'")

class PlayerRegister(Player):
    """Subclass of `Player` that represents the process of player registration process.
    Note that the cached player map is avoided in all calls, to avoid integrity problems.
    """
    @classmethod
    def phase_status(cls) -> str:
        """Return current status of the registration phase (for mobile UI).
        """
        tourn = TournInfo.get()
        nreg = len(list(cls.nums_used()))
        if nreg < tourn.players:
            return f"{nreg} players registered"
        else:
            return "Done"

    @classmethod
    def reg_status(cls, player: Player) -> str:
        """Have to do this as a class method, since we are not (currently) instantiating
        objects for this class.
        """
        return "Registered" if player.player_num else "Pending"

    class Meta:
        table_name = Player._meta.table_name

class PartnerPick(Player):
    """Subclass of `Player` that represents the process of picking partners.  Note that
    the cached player map is avoided in all calls, to avoid integrity problems.
    """
    @classmethod
    def current_round(cls) -> int:
        """Return the current round for partner picking, with the special values of `0` to
        indicate that the seeding stage rankings have not yet been determined, and `-1` to
        indicate that the partner picking stage is complete.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEED_RANKS:
            return 0

        query = (cls
                 .select(fn.count())
                 .where(cls.partner.is_null(False)))
        npicks = query.scalar()
        if npicks < tourn.teams:
            return npicks + 1
        else:
            return -1

    @classmethod
    def phase_status(cls) -> str:
        """Return current status of the partner picking phase (for mobile UI).
        """
        cur_round = cls.current_round()
        if cur_round == 0:
            return "Not Started"
        elif cur_round == -1:
            return "Done"
        else:
            if cur_round == 2:
                # ignore the reigning champ(s) pre-selected team
                npicks = "no"
            else:
                npicks = cur_round - 2
            return f"{npicks} picks made"

    @classmethod
    def current_pick(cls) -> Self:
        """Return top seeded player currently available, which equates to the player
        currently picking during the partner selection process.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEED_RANKS:
            return None

        # NOTE: need to instantiate `Player` instances here
        pl_query = Player.select()
        avail = list(filter(lambda x: x.available, pl_query))
        if not avail:
            return None
        assert len(avail) > 1
        return sorted(avail, key=lambda x: x.player_rank)[0]

    @classmethod
    def avail_picks(cls) -> list[Self]:
        """Strangely (and rather unfortunately) similar to `Player.available_players`,
        except that we stay away from the cached player map here and exclude the current
        picker.  It would be nice to clean things up and eliminate some redundancy (also
        see `current_pick`) and sources of possible confusion (not to mention cache
        problems).
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEED_RANKS:
            return None  # as distinguished from `[]` (below)

        # NOTE: need to instantiate `Player` instances here (as above)
        pl_query = Player.select()
        avail = list(filter(lambda x: x.available, pl_query))
        if not avail:
            return []
        assert len(avail) > 1
        return sorted(avail, key=lambda x: x.player_rank)[1:]

    @classmethod
    def get_picks(cls, all_picks: bool = False) -> list[BaseModel]:
        """Get completed "PartnerPick" records (corresponding to players that have made a
        pick), in order of pick position (i.e. seeding rank), with reigning champs always
        listed first.  `all_picks` indicates that players yet to pick (and not already
        picked themselves) should also be returned.

        This call follows the same semantics as `get_games` (for "BracketPick" objects).
        """
        cur_round = cls.current_round()
        if cur_round == 0:
            return None  # as distinct from [], e.g. pick 1 in progress

        # NOTE: need to instantiate `Player` instances here (as above)--also, don't muck
        # with the cached player map since we will always want to requery and this may be
        # called in (relative) volume; we keep this simple and just do the filtering in
        # code (should probably also do the same elsewhere!)
        pl_list = list(Player.select())
        if all_picks or cur_round == -1:
            includer = lambda x: not x.picked_by
        else:
            includer = lambda x: x.partner
        picks = filter(includer, pl_list)
        return sorted(picks, key=lambda x: (-x.reigning_champ, x.player_rank))

    class Meta:
        table_name = Player._meta.table_name

############
# SeedGame #
############

class SeedGame(BaseModel):
    """
    """
    # required info
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # sd-{rnd}-{tbl}
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num',
                                     null=True)
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    player4        = ForeignKeyField(Player, field='player_num', column_name='player4_num',
                                     null=True)
    team1_name     = TextField(null=True)     # player1_name / player2_name
    team2_name     = TextField(null=True)     # player3_name / player4_name
    bye_players    = TextField(null=True)     # player1 / ...
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.table_num.is_null(False))
        for t in sel.iterator():
            yield t

    @classmethod
    def current_round(cls) -> int:
        """Return the current round of play, with the special values of `0` to indicate
        that the seeding bracket has not yet been created, and `-1` to indicate that the
        seeding stage is complete.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEED_BRACKET:
            return 0

        round_games = tourn.players // 4
        query = (cls
                 .select(cls.round_num, fn.count(cls.id))
                 .where(cls.winner.is_null(False))
                 .group_by(cls.round_num)
                 .order_by(cls.round_num.desc()))
        if not query:
            return 1  # no games yet played
        round_num, ngames = query.scalar(as_tuple=True)

        if ngames < round_games:
            return round_num
        if round_num < tourn.seed_rounds:
            return round_num + 1
        return -1

    @classmethod
    def phase_status(cls) -> str:
        """Return current status of the seeding round phase (for mobile UI).
        """
        cur_round = cls.current_round()
        if cur_round == 0:
            return "Not Started"
        elif cur_round == -1:
            return "Done"
        else:
            return f"Round {cur_round}"

    @property
    def bracket(self) -> str:
        """Display name for the bracket
        """
        return BRACKET_NAME[Bracket.SEED]

    @property
    def player_nums(self) -> str:
        """Used for the seeding view of the UI
        """
        pl_nums = list(filter(bool, (self.player1_num,
                                     self.player2_num,
                                     self.player3_num,
                                     self.player4_num)))
        if len(pl_nums) < 4:
            return ', '.join(map(str, pl_nums))

        return f"{pl_nums[0]} / {pl_nums[1]} vs. {pl_nums[2]} / {pl_nums[3]}"

    @property
    def team_tags(self) -> tuple[str, str]:
        """Team references based on player tags with embedded HTML annotation (used for
        bracket and scores/results displays)--currently, can only be called for actual
        matchup, and not bye records
        """
        p1 = self.player1
        p2 = self.player2
        p3 = self.player3
        p4 = self.player4
        assert p1 and p2 and p3 and p4
        team1_tag = f"{p1.player_tag}&nbsp;&nbsp;/&nbsp;&nbsp;{p2.player_tag}"
        team2_tag = f"{p3.player_tag}&nbsp;&nbsp;/&nbsp;&nbsp;{p4.player_tag}"
        return team1_tag, team2_tag

    @property
    def bye_tags(self) -> list[str]:
        """Bye references based on player tags with embedded HTML annotation (used for
        bracket and scores/results displays)--currently, can only be called for bye
        records
        """
        pl_list = list(filter(bool, (self.player1,
                                     self.player2,
                                     self.player3,
                                     self.player4)))
        assert len(pl_list) < 4  # ...or return None?
        return [pl.player_tag for pl in pl_list]

    @property
    def winner_info(self) -> tuple[str, int, int]:
        """Returns tuple(team_name, team_pts)
        """
        if self.team1_name == self.winner:
            return self.team1_tag, self.team1_pts
        else:
            return self.team2_tag, self.team2_pts

    @property
    def loser_info(self) -> tuple[str, int, int]:
        """Returns tuple(team_name, team_pts)
        """
        if self.team1_name == self.winner:
            return self.team2_tag, self.team2_pts
        else:
            return self.team1_tag, self.team1_pts

    @property
    def team1_tag(self) -> str:
        """REVISIT: need to reconcile this with fmt_team_name (in euchmgr.py)!!!
        """
        pl_tag = lambda x: f"{x.nick_name} ({x.player_num})"
        return f"{pl_tag(self.player1)} / {pl_tag(self.player2)}"

    @property
    def team2_tag(self) -> str:
        """REVISIT: need to reconcile this with fmt_team_name (in euchmgr.py)!!!
        """
        pl_tag = lambda x: f"{x.nick_name} ({x.player_num})"
        return f"{pl_tag(self.player3)} / {pl_tag(self.player4)}"

    def team_idx(self, player: Player) -> int:
        """Return the team index for the specified player: `0`, `1`, or `-1`, representing
        team1, team2, or a bye (respectively).  This is used to map into `team_tags`.
        """
        if player in (self.player1, self.player2):
            return 0 if self.table_num else -1
        if player in (self.player3, self.player4):
            return 1 if self.table_num else -1
        raise LogicError(f"player '{player.nick_name}' not in seed_game '{self.label}'")

    def team_info(self, player: Player) -> tuple[str, int, int]:
        """Returns tuple(team_name, team_pts)
        """
        if self.is_winner(player):
            return self.winner_info
        else:
            return self.loser_info

    def opp_info(self, player: Player) -> tuple[str, int, int]:
        """Returns tuple(team_name, team_pts)
        """
        if self.is_winner(player):
            return self.loser_info
        else:
            return self.winner_info

    def is_winner(self, player: Player) -> bool:
        """Cleaner interface for use in templates
        """
        pg = PlayerGame.get(PlayerGame.player == player,
                            PlayerGame.game_label == self.label)
        return pg.is_winner

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  It is no longer required
        that score updates come through here (since denorms are now managed elsewhere),
        but there is a little bit of integrity checking here that is slightly useful
        """
        if self.winner:
            raise RuntimeError("Completed game score cannot be overwritten")
        if not (0 <= (team1_pts or 0) <= GAME_PTS and 0 <= (team2_pts or 0) <= GAME_PTS):
            raise RuntimeError(f"Invalid score specified (must be between 0 and {GAME_PTS} points")

        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

    def update_player_stats(self) -> int:
        """Update stats for all players involved in the game; returns number of records
        updated.  Called by front-end after the game is complete (i.e. winner determined).
        There is no need to support partial-game stats.
        """
        players     = [self.player1, self.player2, self.player3, self.player4]
        team_scores = [self.team1_pts, self.team2_pts]

        upd = 0
        for pl_idx, player in enumerate(players):
            tm_idx   = pl_idx // 2
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            player.seed_wins        += int(team_pts > opp_pts)
            player.seed_losses      += int(team_pts < opp_pts)
            player.seed_pts_for     += team_pts
            player.seed_pts_against += opp_pts

            ngames = player.seed_wins + player.seed_losses
            totpts = player.seed_pts_for + player.seed_pts_against
            player.seed_win_pct = rnd_pct(player.seed_wins / ngames)
            player.seed_pts_pct = rnd_pct(player.seed_pts_for / totpts)
            upd += player.save()

        return upd

    def insert_player_games(self) -> int:
        """Insert a record into the PlayerGame denorm for all players involved in the
        game; returns number of records inserted.  Called by front-end after the game is
        complete (i.e. winner determined)
        """
        bracket = Bracket.SEED
        players = [self.player1, self.player2, self.player3, self.player4]
        if self.table_num is None:
            assert self.bye_players is not None
            assert players[0] is not None
            assert players[-1] is None
            byes = list(filter(None, players))
            for player in byes:
                pg_info = {'bracket'   : bracket,
                           'round_num' : self.round_num,
                           'game_label': self.label,
                           'player'    : player,
                           'is_bye'    : True}
                tm_game = PlayerGame.create(**pg_info)
            return len(byes)

        partners    = [self.player2, self.player1, self.player4, self.player3]
        opps_tups   = [(self.player3, self.player4), (self.player1, self.player2)]
        team_scores = [self.team1_pts, self.team2_pts]

        pl_games = []
        for pl_idx, player in enumerate(players):
            tm_idx   = pl_idx // 2
            op_idx   = tm_idx ^ 0x01
            partner  = partners[pl_idx]
            opps_tup = opps_tups[tm_idx]
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            pg_info = {'bracket'      : bracket,
                       'round_num'    : self.round_num,
                       'game_label'   : self.label,
                       'player'       : player,
                       'partners'     : [partner.player_num],
                       'opponents'    : [p.player_num for p in opps_tup],
                       'partner_names': [partner.nick_name],
                       'opp_names'    : [p.nick_name for p in opps_tup],
                       'team_pts'     : team_pts,
                       'opp_pts'      : opp_pts,
                       'is_winner'    : team_pts > opp_pts}
            pl_game = PlayerGame.create(**pg_info)
            pl_games.append(pl_game)

        return len(pl_games)

    def save(self, *args, **kwargs):
        """Determine (and set) winner if game is complete
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in {self.team1_pts, self.team2_pts}:
                if self.team1_pts >= GAME_PTS:
                    if self.team2_pts >= GAME_PTS:
                        raise RuntimeError(f"Only one team can score game-winning points ({GAME_PTS})")
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

########
# Team #
########

EMPTY_TEAM_STATS = {
    'tourn_wins'       : None,
    'tourn_losses'     : None,
    'tourn_pts_for'    : None,
    'tourn_pts_against': None
}

EMPTY_FINAL_FOUR_STATS = {
    'playoff_match_wins'  : None,
    'playoff_match_losses': None,
    'playoff_wins'        : None,
    'playoff_losses'      : None,
    'playoff_pts_for'     : None,
    'playoff_pts_against' : None
}

# special (i.e. hack) value representing n/a (must be a float)
PTS_PCT_NA = -1.0

class Team(BaseModel):
    """
    """
    # required info
    player1        = ForeignKeyField(Player, field='player_num', column_name='player1_num')
    player2        = ForeignKeyField(Player, field='player_num', column_name='player2_num')
    player3        = ForeignKeyField(Player, field='player_num', column_name='player3_num',
                                     null=True)
    is_thm         = BooleanField(default=False)
    team_name      = TextField(unique=True)
    avg_player_rank = FloatField()
    top_player_rank = IntegerField()
    # tournament bracket
    team_seed      = IntegerField(unique=True, null=True)  # 1-based, based on player seeds
    div_num        = IntegerField(null=True)
    div_seed       = IntegerField(null=True)
    # tournament play
    tourn_wins     = IntegerField(default=0)
    tourn_losses   = IntegerField(default=0)
    tourn_win_pct  = FloatField(null=True)
    tourn_pts_for  = IntegerField(default=0)
    tourn_pts_against = IntegerField(default=0)
    tourn_pts_pct  = FloatField(null=True)
    tourn_pos      = IntegerField(null=True)  # based on win_pct, ties possible
    div_pos        = IntegerField(null=True)  # same
    # playoff play
    playoff_match_wins = IntegerField(default=0)
    playoff_match_losses = IntegerField(default=0)
    playoff_wins   = IntegerField(default=0)
    playoff_losses = IntegerField(default=0)
    playoff_win_pct = FloatField(null=True)
    playoff_pts_for = IntegerField(default=0)
    playoff_pts_against = IntegerField(default=0)
    playoff_pts_pct = FloatField(null=True)
    playoff_pos    = IntegerField(null=True)  # REVISIT: probably don't need this!!!
    playoff_rank   = IntegerField(null=True)  # apply to top four tourn_rank_adj
    # tie-breaker stuff
    div_tb_crit    = JSONField(null=True)     # stats criteria used to compute final rank
    div_tb_data    = JSONField(null=True)     # raw data for reference
    div_rank       = IntegerField(null=True)  # stack-ranked, no ties
    div_rank_adj   = IntegerField(null=True)  # playoff determination overrides
    tourn_tb_crit  = JSONField(null=True)     # stats criteria used to compute final rank
    tourn_tb_data  = JSONField(null=True)     # raw data for reference
    tourn_rank     = IntegerField(null=True)  # stack-ranked, no ties
    tourn_rank_adj = IntegerField(null=True)  # includes playoff_rank overwrite

    # class variables
    team_map: ClassVar[dict[int, Self]] = None  # indexed by id

    class Meta:
        indexes = (
            (('div_num', 'div_seed'), True),
        )

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above)
        """
        cls.team_map = None

    @classmethod
    def get_team_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all teams, indexed by id
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.TOURN_TEAMS:
            raise LogicError("tournament teams not yet created")

        if cls.team_map and not requery:
            return cls.team_map

        cls.team_map = {}
        for t in cls.select().iterator():
            cls.team_map[t.id] = t
        return cls.team_map

    @classmethod
    def get_div_map(cls, div: int, requery: bool = False) -> dict[int, Self]:
        """Return dict of division teams, indexed by div_seed
        """
        tm_list = cls.get_team_map(requery).values()
        return {t.div_seed: t for t in tm_list if t.div_num == div}

    @classmethod
    def iter_teams(cls, div: int = None, by_rank: bool = False) -> Iterator[Self]:
        """Iterator for teams (wrap ORM details).  Note that this also clears out local
        cache, if populated.
        """
        if cls.team_map:
            cls.team_map = None
        query = cls.select()
        if div:
            query = query.where(cls.div_num == div)
            if by_rank:
                query = query.order_by(cls.div_rank.asc(nulls='last'))
        elif by_rank:
            query = query.order_by(cls.tourn_rank.asc(nulls='last'))
        for t in query.iterator():
            yield t

    @classmethod
    def iter_playoff_teams(cls, by_rank: bool = False) -> Iterator[Self]:
        """Iterator for playoff teams (wrap ORM details).  Note that this also clears out
        local cache, if populated.
        """
        # NOTE: we don't need to clear out cache here, since this is not used exactly like
        # `iter_teams()`, above
        query = cls.select().where(cls.div_rank.in_([1, 2]))
        if by_rank:
            query = query.order_by(cls.tourn_rank.asc(nulls='last'))
        for t in query.iterator():
            yield t

    @classmethod
    def ident_div_tbs(cls, div_num: int, div_pos: int) -> list[list[Self]]:
        """Report teams with identical tie-break criteria for a divisional cohort
        (identical overall win percentage)
        """
        tbs = []
        query = (Team
                 .select(Team.div_tb_crit,
                         fn.group_concat(Team.id))
                 .where(Team.div_num == div_num,
                        Team.div_pos == div_pos,
                        Team.team_seed.is_null(False))
                 .group_by(Team.div_tb_crit)
                 .having(fn.count() > 1))
        for grp in query:
            ids: list[str] = grp.__data__['id'].split(',')
            teams: list[Team] = [Team.get(int(x)) for x in ids]
            tbs.append(teams)
        return tbs

    @property
    def team_data(self) -> dict:
        """Return team data as a dict, removing distracting default values if not relevant
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.TOURN_BRACKET:
            return self.__data__ | EMPTY_TEAM_STATS
        return self.__data__

    @property
    def final_four_data(self) -> dict:
        """Return final four team data as a dict, removing distracting default values if
        not relevant
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.SEMIS_BRACKET:
            return self.__data__ | EMPTY_FINAL_FOUR_STATS
        return self.__data__

    @property
    def is_champ(self) -> bool:
        """Note that the property (i.e. return) value is different than Player.champ
        """
        assert self.player2.champ == self.player1.champ
        if self.player3:
            assert self.player3.champ == self.player1.champ
        return bool(self.player1.champ)

    @property
    def team_tag(self) -> str:
        """Combination of div_seed and team_name with embedded HTML annotation (used for
        bracket and scores/results displays)
        """
        return f"<b>{self.div_seed}</b>&nbsp;&nbsp;<u>{self.team_name}</u>"

    @property
    def player_nums(self) -> str:
        """
        """
        pl_nums = list(filter(bool, (self.player1_num,
                                     self.player2_num,
                                     self.player3_num)))
        return ' / '.join(map(str, pl_nums))

    @property
    def div_pos_str(self) -> str | None:
        """Same as div_pos, except annotated if tied with others
        """
        if self.div_pos is None:
            return None
        elif not self.div_tb_crit:
            return str(self.div_pos)
        return f"{self.div_pos}*"

    @property
    def div_tb_win_rec(self) -> str | None:
        """Tie-breaker (head-to-head) win-loss record as a string
        """
        if not self.div_tb_data:
            return None
        return f"{self.div_tb_data['wins']}-{self.div_tb_data['losses']}"

    @property
    def div_tb_pts_rec(self) -> str | None:
        """Tie-breaker (head-to-head) points for-and-against record as a string
        """
        if not self.div_tb_data:
            return None
        return f"{self.div_tb_data['pts_for']}-{self.div_tb_data['pts_against']}"

    @property
    def div_tb_pts_pct(self) -> float | None:
        """Tie-breaker (head-to-head) points percentage (points-for over total points)
        """
        if not self.div_tb_data:
            return None
        tb_pts_tot = self.div_tb_data['pts_for'] + self.div_tb_data['pts_against']
        if tb_pts_tot == 0.0:
            return PTS_PCT_NA
        return rnd_pct(self.div_tb_data['pts_for'] / tb_pts_tot)

    @property
    def div_rank_final(self, annotated: bool = False) -> int | str:
        """The official value for division ranking (defaults to div_rank, with override
        from div_rank_adj).  String value is returned if `annotated` is specified as True,
        with override indicated (if present).
        """
        if annotated:
            if self.div_rank_adj:
                return f"{self.div_rank_adj} ({self.div_rank})"
            else:
                return str(self.div_rank)

        return self.div_rank_adj or self.div_rank

    @property
    def current_game(self) -> BaseModel:
        """Return current TournGame for team (only if round robin stage is active)
        """
        tg = (TeamGame
              .select(fn.max(TeamGame.round_num))
              .where(TeamGame.team == self,
                     TeamGame.is_bye == False)
              .get())
        last_round = tg.round_num or 0
        cg = (TournGame
              .select()
              .where((TournGame.team1 == self) |
                     (TournGame.team2 == self))
              .where(TournGame.table_num.is_null(False),
                     TournGame.round_num > last_round)
              .order_by(TournGame.round_num))
        return cg[0] if len(cg) > 0 else None

    def get_games(self, all_games: bool = False) -> list[BaseModel]:
        """Get completed TournGame records (including possible byes up to the current
        round for the stage).
        """
        cur_round = TournGame.current_round()
        if cur_round == 0:
            return None  # as distinct from [], e.g. game 1 in progress
        query = (TournGame
                 .select()
                 .where((TournGame.team1 == self) |
                        (TournGame.team2 == self))
                 .order_by(TournGame.round_num))
        if cur_round != -1 and not all_games:
            query = query.where(TournGame.round_num <= cur_round)
        return list(query)

    def get_opps_games(self, opps: list[Self]) -> list[BaseModel]:
        """Get TournGame records for all games versus specified opponents
        """
        query = (TournGame
                 .select()
                 .join(TeamGame, on=(TeamGame.game_label == TournGame.label))
                 .where(TeamGame.team == self,
                        TeamGame.opponent.in_(opps)))
        return list(query)

    def get_wins(self, opps: list[Self]) -> list[BaseModel]:
        """Get TeamGame records for all wins versus specified opponents
        """
        query = (TeamGame
                 .select()
                 .where(TeamGame.team == self,
                        TeamGame.opponent.in_(opps),
                        TeamGame.is_winner == True))
        return list(query)

    def get_game_stats(self, opps: list[Self] = None) -> dict:
        """Get stats for team's games (all, or versus specified opponents)
        """
        stat_keys = ('games', 'wins', 'team_pts', 'opp_pts')
        query = (TeamGame
                 .select(fn.count(TeamGame.id),
                         fn.sum(TeamGame.is_winner),
                         fn.sum(TeamGame.team_pts),
                         fn.sum(TeamGame.opp_pts))
                 .where(TeamGame.team == self))
        if opps:
            # note that `opponent` is defined as a foreign key, so the ORM will extract
            # the right column in `opps` for the `in_` operator
            query = query.where(TeamGame.opponent.in_(opps))
        return dict(zip(stat_keys, query[0].__data__.values()))

    def save_team_refs(self) -> None:
        """Add team reference to player members, and save.
        """
        self.player1.team = self
        self.player2.team = self
        self.player1.save()
        self.player2.save()
        if self.player3:
            self.player3.team = self
            self.player3.save()

#############
# TournGame #
#############

class TournGame(BaseModel):
    """
    """
    # required info
    div_num        = IntegerField()
    round_num      = IntegerField()
    table_num      = IntegerField(null=True)  # null if bye
    label          = TextField(unique=True)   # rr-{div}-{rnd}-{tbl}
    team1          = ForeignKeyField(Team, column_name='team1_id')
    team2          = ForeignKeyField(Team, column_name='team2_id', null=True)
    team1_name     = TextField(null=True)     # denorm (null if team1 is bye_team)
    team2_name     = TextField(null=True)     # denorm
    bye_team       = TextField(null=True)
    team1_div_seed = IntegerField()
    team2_div_seed = IntegerField(null=True)
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('div_num', 'round_num', 'table_num'), True),
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for tourn_games (wrap ORM details).
        """
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.table_num.is_null(False))
        for t in sel.iterator():
            yield t

    @classmethod
    def current_round(cls) -> int:
        """Return the current round of play, with the special values of `0` to indicate
        that the round robin brackets have not yet been created, and `-1` to indicate that
        the round robin stage is complete.
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.TOURN_BRACKET:
            return 0

        round_games = tourn.teams // 2
        query = (cls
                 .select(cls.round_num, fn.count(cls.id))
                 .where(cls.winner.is_null(False))
                 .group_by(cls.round_num)
                 .order_by(cls.round_num.desc()))
        if not query:
            return 1  # no games yet played
        round_num, ngames = query.scalar(as_tuple=True)

        if ngames < round_games:
            return round_num
        if round_num < tourn.tourn_rounds:
            return round_num + 1
        return -1

    @classmethod
    def phase_status(cls) -> str:
        """Return current status of the round robin phase (for mobile UI).
        """
        cur_round = cls.current_round()
        if cur_round == 0:
            return "Not Started"
        elif cur_round == -1:
            return "Done"
        else:
            return f"Round {cur_round}"

    @property
    def bracket(self) -> str:
        """Display name for the bracket
        """
        return BRACKET_NAME[Bracket.TOURN]

    @property
    def team_seeds(self) -> str:
        """
        """
        tm_seeds = (self.team1_div_seed, self.team2_div_seed)
        return ' vs. '.join(str(x) for x in tm_seeds if x)

    @property
    def team_tags(self) -> tuple[str, str]:
        """Team tags with embedded HTML annotation (used for bracket and scores/results
        displays)--currently, can only be called for actual matchup, and not bye records
        """
        assert self.team1 and self.team2
        return self.team1.team_tag, self.team2.team_tag

    @property
    def bye_tag(self) -> str:
        """Bye reference based on team tags with embedded HTML annotation (used for
        bracket and scores/results displays)--currently, can only be called for bye
        records
        """
        assert self.team1 and self.team2 is None  # ...or return None?
        return self.team1.team_tag

    @property
    def winner_info(self) -> tuple[str, int, int]:
        """Returns tuple(name, div_seed, pts)
        """
        if self.team1_name == self.winner:
            return self.team1_name, self.team1_div_seed, self.team1_pts
        else:
            return self.team2_name, self.team2_div_seed, self.team2_pts

    @property
    def loser_info(self) -> tuple[str, int, int]:
        """Returns tuple(name, div_seed, pts)
        """
        if self.team1_name == self.winner:
            return self.team2_name, self.team2_div_seed, self.team2_pts
        else:
            return self.team1_name, self.team1_div_seed, self.team1_pts

    def team_idx(self, team: Team) -> int:
        """Return the team index for the specified team: `0`, `1`, or `-1`, representing
        team1, team2, or a bye (respectively).  This is used to map into `team_tags`.
        """
        if team == self.team1:
            return 0 if self.table_num else -1
        if team == self.team2:
            return 1 if self.table_num else -1
        raise LogicError(f"team '{team.team_name}' not in tourn_game '{self.label}'")

    def team_info(self, team: Team) -> tuple[str, int, int]:
        """Returns tuple(name, div_seed, pts)
        """
        if self.is_winner(team):
            return self.winner_info
        else:
            return self.loser_info

    def opp_info(self, team: Team) -> tuple[str, int, int]:
        """Returns tuple(name, div_seed, pts)
        """
        if self.is_winner(team):
            return self.loser_info
        else:
            return self.winner_info

    def is_winner(self, team: Team) -> bool:
        """Cleaner interface for use in templates
        """
        return team.team_name == self.winner

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  It is no longer required
        that score updates come through here (since denorms are now managed elsewhere),
        but there is a little bit of integrity checking here that is slightly useful
        """
        if self.winner:
            raise RuntimeError("Completed game score cannot be overwritten")
        if not (0 <= (team1_pts or 0) <= GAME_PTS and 0 <= (team2_pts or 0) <= GAME_PTS):
            raise RuntimeError(f"Invalid score specified (must be between 0 and {GAME_PTS} points")

        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

    def update_team_stats(self) -> int:
        """Update stats for teams involved in the game; returns number of records updated.
        Called by front-end after the game is complete (i.e. winner determined).  There is
        no need to support partial-game stats.
        """
        teams       = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        upd = 0
        for tm_idx, team in enumerate([self.team1, self.team2]):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            team.tourn_wins        += int(team_pts > opp_pts)
            team.tourn_losses      += int(team_pts < opp_pts)
            team.tourn_pts_for     += team_pts
            team.tourn_pts_against += opp_pts

            ngames = team.tourn_wins + team.tourn_losses
            totpts = team.tourn_pts_for + team.tourn_pts_against
            team.tourn_win_pct = rnd_pct(team.tourn_wins / ngames)
            team.tourn_pts_pct = rnd_pct(team.tourn_pts_for / totpts)
            upd += team.save()

        return upd

    def insert_team_games(self) -> int:
        """Insert a record into the TeamGame denorm for teams involved in the game;
        returns number of records inserted.  Called by front-end after the game is
        complete (i.e. winner determined)
        """
        bracket = Bracket.TOURN
        if self.table_num is None:
            assert self.bye_team is not None
            assert self.team1 is not None
            assert self.team2 is None
            tg_info = {'bracket'   : bracket,
                       'round_num' : self.round_num,
                       'game_label': self.label,
                       'team'      : self.team1,
                       'is_bye'    : True}
            tm_game = TeamGame.create(**tg_info)
            return 1

        teams       = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        tm_games = []
        for tm_idx, team in enumerate([self.team1, self.team2]):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            tg_info = {'bracket'   : bracket,
                       'round_num' : self.round_num,
                       'game_label': self.label,
                       'team'      : team,
                       'opponent'  : teams[op_idx],
                       'team_pts'  : team_pts,
                       'opp_pts'   : opp_pts,
                       'is_winner' : team_pts > opp_pts}
            tm_game = TeamGame.create(**tg_info)
            tm_games.append(tm_game)

        return len(tm_games)

    def save(self, *args, **kwargs):
        """Compute winner if both scores have been entered
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in {self.team1_pts, self.team2_pts}:
                if self.team1_pts >= GAME_PTS:
                    if self.team2_pts >= GAME_PTS:
                        raise RuntimeError(f"Only one team can score game-winning points ({GAME_PTS})")
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

###############
# PlayoffGame #
###############

class PlayoffGame(BaseModel):
    """
    """
    # required info
    bracket        = TextField()              # "sf" or "fn"
    matchup_num    = IntegerField()
    round_num      = IntegerField()
    label          = TextField(unique=True)   # {brckt}-{mtchup}-{rnd}
    team1          = ForeignKeyField(Team, column_name='team1_id')
    team2          = ForeignKeyField(Team, column_name='team2_id')
    team1_name     = TextField()              # denorm
    team2_name     = TextField()              # denorm
    team1_div_rank = IntegerField()
    team2_div_rank = IntegerField()
    # results
    team1_pts      = IntegerField(null=True)
    team2_pts      = IntegerField(null=True)
    winner         = TextField(null=True)     # team name

    class Meta:
        indexes = (
            (('bracket', 'matchup_num', 'round_num'), True),
        )

    @classmethod
    def iter_games(cls, bracket: Bracket = None, by_matchup: bool = False) -> Iterator[Self]:
        """Iterator for playoff_games (wrap ORM details).
        """
        sel = cls.select()
        if bracket:
            sel = sel.where(cls.bracket == bracket)
        if by_matchup:
            sel = sel.order_by(cls.bracket, cls.matchup_num)
        for t in sel.iterator():
            yield t

    @classmethod
    def bracket_complete(cls, bracket: Bracket) -> bool:
        """Check if all play associated with the specified bracket is complete.  Must be
        called after `update_team_stats()` for the most recent game.
        """
        tourn = TournInfo.get()
        if bracket == Bracket.SEMIS:
            if tourn.stage_compl < TournStage.SEMIS_BRACKET:
                return False
        else:
            assert bracket == Bracket.FINALS
            if tourn.stage_compl < TournStage.FINALS_BRACKET:
                return False

        query = Team.select(fn.sum(Team.playoff_match_wins))
        nmatches = query.scalar()
        if nmatches > 3:
            raise DataError(f"too many playoff match wins ({nmatches})")

        if bracket == Bracket.SEMIS:
            return nmatches >= 2
        else
            assert bracket == Bracket.FINALS
            return nmatches == 3

    @property
    def team_ranks(self) -> str:
        """Show matchup of tournament (after round robin) rankings.
        """
        tm_ranks = (self.team1.tourn_rank, self.team2.tourn_rank)
        return ' vs. '.join(str(x) for x in tm_ranks if x)

    def add_scores(self, team1_pts: int, team2_pts: int) -> None:
        """Record scores for completed (or incomplete) game.  It is no longer required
        that score updates come through here (since denorms are now managed elsewhere),
        but there is a little bit of integrity checking here that is slightly useful
        """
        if self.winner:
            raise RuntimeError("Completed game score cannot be overwritten")
        if not (0 <= (team1_pts or 0) <= GAME_PTS and 0 <= (team2_pts or 0) <= GAME_PTS):
            raise RuntimeError(f"Invalid score specified (must be between 0 and {GAME_PTS} points")

        self.team1_pts = team1_pts
        self.team2_pts = team2_pts

    def update_team_stats(self) -> int:
        """Update stats for teams involved in the game; returns number of records updated.
        Called by front-end after the game is complete (i.e. winner determined).  There is
        no need to support partial-game stats.
        """
        teams       = [self.team1, self.team2]
        team_scores = [self.team1_pts, self.team2_pts]

        match_idx = None
        for tm_idx, team in enumerate([self.team1, self.team2]):
            op_idx   = tm_idx ^ 0x01
            team_pts = team_scores[tm_idx]
            opp_pts  = team_scores[op_idx]

            team.playoff_wins        += int(team_pts > opp_pts)
            team.playoff_losses      += int(team_pts < opp_pts)
            team.playoff_pts_for     += team_pts
            team.playoff_pts_against += opp_pts

            if team.playoff_wins == 2:
                match_idx = tm_idx

            ngames = team.playoff_wins + team.playoff_losses
            totpts = team.playoff_pts_for + team.playoff_pts_against
            team.playoff_win_pct = rnd_pct(team.playoff_wins / ngames)
            team.playoff_pts_pct = rnd_pct(team.playoff_pts_for / totpts)

        if match_idx is not None:
            op_idx = match_idx ^ 0x01
            teams[match_idx].playoff_match_wins += 1
            teams[op_idx].playoff_match_losses += 1

        upd = teams[0].save() + teams[1].save()
        return upd

    def save(self, *args, **kwargs):
        """Compute winner if both scores have been entered
        """
        if set(self._dirty) & {'team1_pts', 'team2_pts'}:
            if None not in {self.team1_pts, self.team2_pts}:
                if self.team1_pts >= GAME_PTS:
                    if self.team2_pts >= GAME_PTS:
                        raise RuntimeError(f"Only one team can score game-winning points ({GAME_PTS})")
                    self.winner = self.team1_name
                elif self.team2_pts >= GAME_PTS:
                    self.winner = self.team2_name
                else:
                    self.winner = None
        return super().save(*args, **kwargs)

##############
# PlayerGame #
##############

class PlayerGame(BaseModel):
    """Denormalization of SeedGame (and possibly TournGame data), for use in computing
    stats, determining head-to-head match-ups, etc.
    """
    bracket        = TextField()            # "sd" (or "rr", etc. if tabulating for players)
    round_num      = IntegerField()
    game_label     = TextField()            # sd-{rnd}-{tbl}, rr-{div}-{rnd}-{tbl}, etc.
    player         = ForeignKeyField(Player, field='player_num', column_name='player_num')
    player_name    = TextField()            # automatic denorm
    partners       = JSONField(null=True)   # array of partner player_num(s)
    opponents      = JSONField(null=True)   # array of opposing player_nums
    partner_names  = JSONField(null=True)   # denorm
    opp_names      = JSONField(null=True)   # denorm
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'player'), True),
            (('game_label', 'player'), True)
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for seed_games (wrap ORM details).
        """
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.is_bye == False)
        for t in sel.iterator():
            yield t

    def save(self, *args, **kwargs):
        """Set player name (denorm field) as player's nick name
        """
        if not self.player_name:
            self.player_name = self.player.nick_name
        return super().save(*args, **kwargs)

############
# TeamGame #
############

class TeamGame(BaseModel):
    """Denormalization of TournGame data, for use in computing stats, determining
    head-to-head match-ups, etc.
    """
    bracket        = TextField()           # "rr", "sf", or "fn"
    round_num      = IntegerField()
    game_label     = TextField()           # rr-{div}-{rnd}-{tbl}, etc.
    team           = ForeignKeyField(Team)
    opponent       = ForeignKeyField(Team, column_name='opp_id', null=True)
    team_name      = TextField()
    opp_name       = TextField(null=True)  # or "bye"(?)
    is_bye         = BooleanField(default=False)
    # results
    team_pts       = IntegerField(null=True)
    opp_pts        = IntegerField(null=True)
    is_winner      = BooleanField(null=True)

    class Meta:
        indexes = (
            (('bracket', 'round_num', 'team'), True),
            (('game_label', 'team'), True)
        )

    @classmethod
    def iter_games(cls, include_byes: bool = False) -> Iterator[Self]:
        """Iterator for tourn_games (wrap ORM details).
        """
        sel = cls.select()
        if not include_byes:
            sel = sel.where(cls.is_bye == False)
        for t in sel.iterator():
            yield t

    def save(self, *args, **kwargs):
        """Set team and opponane names (denorm fields)
        """
        if not self.team_name:
            self.team_name = self.team.team_name
        if self.opponent and not self.opp_name:
            self.opp_name = self.opponent.team_name
        return super().save(*args, **kwargs)

#############
# PostScore #
#############

class ScoreAction(StrEnum):
    SUBMIT  = "submit"
    ACCEPT  = "accept"
    CORRECT = "correct"
    IGNORE  = " (ignored)"
    DISCARD = " (discarded)"

class PostScore(BaseModel):
    """Denormalization of TournGame data, for use in computing stats, determining
    head-to-head match-ups, etc.
    """
    bracket        = TextField()              # "sd", "rr", "sf", or "fn"
    game_label     = TextField()              # sd-{rnd}-{tbl}, rr-{div}-{rnd}-{tbl}, etc.
    post_action    = TextField()
    action_info    = TextField(null=True)
    team1_pts      = IntegerField()
    team2_pts      = IntegerField()
    posted_by      = ForeignKeyField(Player, field='player_num', column_name='posted_by_num')
    team_idx       = IntegerField()           # for `posted_by` (`0` - team1, `1` - team2)
    ref_score      = ForeignKeyField('self', null=True)
    do_push        = BooleanField(null=True)

    class Meta:
        indexes = (
            (('game_label', 'created_at'), False),
        )

    @classmethod
    def fetch_by_id(cls, id: int) -> Self:
        """Wrapper around `get_or_none`, but detect empty `id` arg (and also goot to hide
        ORM details).
        """
        if not id:
            return None
        return cls.get_or_none(id)

    @classmethod
    def get_posts(cls, label: str) -> list[Self]:
        """Return PostScore records for specified game label, in chronological order.
        """
        query = (cls
                 .select()
                 .where(cls.game_label == label)
                 .order_by(cls.id))
        return list(query)

    @classmethod
    def get_last(cls, label: str, include_accept: bool = False) -> Self:
        """Get most recent submitted score for specified game label.  Return `None` if no
        scores posted.
        """
        assert label
        actions = [ScoreAction.SUBMIT, ScoreAction.CORRECT]
        if include_accept:
            actions.append(ScoreAction.ACCEPT)
        query = (cls
                 .select()
                 .where(cls.game_label == label,
                        cls.post_action.in_(actions))
                 .order_by(cls.id.desc())
                 .limit(1))
        return query.get_or_none()

    def push_scores(self) -> None:
        """Push accepted scores to appropriate bracket.
        """
        assert self.do_push
        if self.bracket == Bracket.SEED:
            game = SeedGame.get(SeedGame.label == self.game_label)
            game.add_scores(self.team1_pts, self.team2_pts)
            game.save()
            if game.winner:
                game.update_player_stats()
                game.insert_player_games()
        elif self.bracket == Bracket.TOURN:
            game = TournGame.get(TournGame.label == self.game_label)
            game.add_scores(self.team1_pts, self.team2_pts)
            game.save()
            if game.winner:
                game.update_team_stats()
                game.insert_team_games()
        else:
            raise LogicError(f"Invalid bracket '{self.bracket}'")

#################
# schema_create #
#################

ALL_MODELS = [TournInfo, Player, SeedGame, Team, TournGame, PlayoffGame, PlayerGame,
              TeamGame, PostScore]

def schema_create(models: list[BaseModel | str] | str = None, force = False) -> None:
    """Create tables for specified models (list of objects or comma-separated list of
    names), or all models if no list is specified.
    """
    if models is None:
        models = ALL_MODELS
    elif isinstance(models, str):
        models = models.split(',')
    assert isinstance(models, list)
    if isinstance(models[0], str):
        models_new = []
        for model in models:
            if model not in globals():
                raise RuntimeError(f"Model {model} not imported")
            model_obj = globals()[model]
            if not issubclass(model_obj, BaseModel):
                raise RuntimeError(f"Model {model} must be subclass of `BaseModel`")
            models_new.append(model_obj)
        models = models_new

    if force:
        # we just drop all tables so we don't have to worry about integrity, cascading
        # deletes, legacy data, etc. (our version of `safe=False`)
        for model in reversed(models):
            model.drop_table()
    else:
        # the existenace of ANY of the specified tables disqualifies the entire request
        for model in models:
            if model.table_exists():
                table_name = model._meta.table_name
                raise OperationalError(f'table "{table_name}" already exists')

    for model in models:
        model.create_table(safe=False)
