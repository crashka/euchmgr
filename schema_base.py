# -*- coding: utf-8 -*-

from enum import IntEnum, StrEnum
from typing import ClassVar, Self, NamedTuple
from datetime import datetime, date

from peewee import Model, DateTimeField, TextField, IntegerField

from database import db

#####################
# utility functions #
#####################

TIME_FMT = '%Y-%m-%d %H:%M:%S'

def now_str() -> str:
    """Readable format that works for string comparisons
    """
    return datetime.now().strftime(TIME_FMT)

#############
# BaseModel #
#############

class BaseModel(Model):
    """Base model for this module, with defaults and system columns
    """
    # system columns
    created_at = DateTimeField(default=now_str)
    updated_at = DateTimeField()

    def save(self, *args, **kwargs):
        if not self._dirty:
            return False  # this is what peewee does if no dirty fields
        if not self.updated_at:
            self.updated_at = self.created_at
        elif 'updated_at' not in self._dirty:
            self.updated_at = now_str()
        return super().save(*args, **kwargs)

    class Meta:
        database = db
        legacy_table_names = False
        only_save_dirty = True

######################
# bracket/game stuff #
######################

DFLT_SEED_ROUNDS  = 8
DFLT_TOURN_ROUNDS = 8
DFLT_DIVISIONS    = 2

GAME_PTS          = 10

class Bracket(StrEnum):
    SEED   = 'sd'
    TOURN  = 'rr'  # for "round robin"
    SEMIS  = 'sf'
    FINALS = 'fn'

BRACKET_NAME = {
    Bracket.SEED  : "Seeding",
    Bracket.TOURN : "Round Robin",
    Bracket.SEMIS : "Semifinals",
    Bracket.FINALS: "Finals",
}

##########################
# tournament stage stuff #
##########################

# stage values are chronologically sequenced
TournStage = IntEnum('TournStage',
                     ['TOURN_CREATE',    # 1
                      'PLAYER_ROSTER',
                      'PLAYER_NUMS',
                      'SEED_BRACKET',
                      'SEED_RESULTS',    # 5
                      'SEED_TABULATE',
                      'SEED_RANKS',
                      'PARTNER_PICK',
                      'TOURN_TEAMS',
                      'TEAM_SEEDS',      # 10
                      'TOURN_BRACKET',
                      'TOURN_RESULTS',
                      'TOURN_TABULATE',
                      'TOURN_RANKS',
                      'SEMIS_BRACKET',   # 15
                      'SEMIS_RESULTS',
                      'SEMIS_TABULATE',
                      'SEMIS_RANKS',
                      'FINALS_BRACKET',
                      'FINALS_RESULTS',  # 20
                      'FINALS_TABULATE',
                      'FINALS_RANKS'])

# represents virtual stages before and after TournStage entries
TOURN_INIT = 0
TOURN_FINAL = len(TournStage) + 1
ACTIVE_STAGES = range(TournStage.PLAYER_ROSTER, TOURN_FINAL)

class StageInfo(NamedTuple):
    """Behavior parameters and messages for tournament stages

    REVISIT(?): there is currently redundancy in the two boolean flags, but we may keep it
    this way for integrity checking
    """
    long_running: bool  # possible manual data entry/finalization in order to complete
    auto_advance: bool  # start next stage automatically upon completion
    start_msg:    str   # only needed if long_running
    compl_msg:    str   # not visible if auto_advance (though specified regardless)

# NOTE that we are being a little particular/pedantic about wording for messages here:
# - "seed" means assigned position within a bracket based on past performance
# - "seeding" means the seeding round process
# - "round robin" means the main tournament, not including playoffs
# - "playoffs" means the semi-final and final rounds of the tournament
# - "rank" or "ranking" means finish position after play is over
# - "position" means order on the scale of performance during play
# - "completed" means data entry of an activity (e.g. playing or picking) is done
# - "computed" or "tabulated" means something algorithmically generated by the program
# - "assigned" means the completion of a process that may be either manual or automated
#
STAGE_DATA = [
    StageInfo(False, False, None,                            "New tournament"),
    StageInfo(True,  True,  "Creating player roster",        "Player roster created"),
    StageInfo(True,  False, "Assigning player nums",         "Player nums assigned"),
    StageInfo(False, True,  "Generate seeding bracket",      "Seeding bracket created"),
    StageInfo(True , False, "Seeding round active",          "Seeding results completed"),
    StageInfo(False, False, "Tabulate seeding results",      "Seeding results tabulated"),
    StageInfo(False, True,  None,                            "Seeding rankings computed"),
    StageInfo(True,  False, "Picking partners",              "Partner picks completed"),
    StageInfo(False, False, "Generate round robin brackets", "Round robin teams created"),
    StageInfo(False, False, None,                            "Round robin team seeds computed"),
    StageInfo(False, True,  None,                            "Round robin brackets created"),
    StageInfo(True,  False, "Round robin play active",       "Round robin results completed"),
    StageInfo(False, False, "Tabulate round robin results",  "Round robin results tabulated"),
    StageInfo(False, False, None,                            "Team rankings computed"),
    StageInfo(False, True,  None,                            "Semifinals brackets created"),
    StageInfo(True,  False, "Semifinals play active",        "Semifinals results completed"),
    StageInfo(False, False, "Tabulate semifinals results",   "Semifinals results tabulated"),
    StageInfo(False, False, None,                            "Semifinals rankings computed"),
    StageInfo(False, True,  None,                            "Finals brackets created"),
    StageInfo(True,  False, "Finals play active",            "Finals results completed"),
    StageInfo(False, False, "Tabulate finals results",       "Finals results tabulated"),
    StageInfo(False, False, None,                            "Finals rankings computed")
]

assert len(STAGE_DATA) == len(TournStage)  # not ensured by zip
StageData = dict(zip(TournStage, STAGE_DATA))

#################
# TournInfoBase #
#################

class TournInfoBase(BaseModel):
    """High-level tournament information.  There is only one instance per database (since
    the database encapsulates the entire data for a single tournament).
    """
    name           = TextField(unique=True)
    dates          = TextField(null=True)
    venue          = TextField(null=True)
    stage_start    = IntegerField()
    stage_compl    = IntegerField()
    cur_stage      = TextField()
    next_action    = TextField(null=True)
    players        = IntegerField(null=True)
    teams          = IntegerField(null=True)
    thm_teams      = IntegerField(null=True)
    seed_rounds    = IntegerField(default=DFLT_SEED_ROUNDS)
    tourn_rounds   = IntegerField(default=DFLT_TOURN_ROUNDS)
    divisions      = IntegerField(default=DFLT_DIVISIONS)
    dflt_pw_hash   = TextField(null=True)  # initial/default pw_hash for players

    # class variables
    inst: ClassVar[Self] = None  # singleton instance

    class Meta:
        table_name = 'tourn_info'

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above)
        """
        cls.inst = None

    @classmethod
    def get(cls, requery: bool = False) -> Self:
        """Return cached singleton instance (purposefully shadows more general base class
        method).
        """
        if cls.inst is None or requery:
            res = [t for t in cls.select().limit(2).iterator()]
            assert len(res) == 1  # fails if not initialized, or unexpected multiple records
            cls.inst = res[0]
        return cls.inst

    @classmethod
    def mark_stage_start(cls, stage: TournStage) -> None:
        """Mark the start of the specified stage (and save) for the cached singleton
        """
        tourn = cls.get()
        tourn.start_stage(stage)

    @classmethod
    def mark_stage_complete(cls, stage: TournStage) -> None:
        """Mark the completion of the specified stage (and save) for the cached singleton
        """
        tourn = cls.get()
        tourn.complete_stage(stage)

    def save(self, *args, **kwargs):
        """Manage stage changes and associated message text
        """
        if 'stage_compl' in self._dirty:
            stage_data = StageData[self.stage_compl]

            if self.stage_start != self.stage_compl:
                assert not self.stage_start or self.stage_start < self.stage_compl
                # set stage_start implicitly (e.g. for for short operations)
                self.stage_start = self.stage_compl

            if stage_data.auto_advance:
                # this may overwrite the update above, but we leave things like this for
                # the associated integrity checking
                stage_next = self.stage_compl + 1
                self.stage_start = stage_next
                self.cur_stage = StageData[stage_next].start_msg
                self.next_action = StageData[stage_next].compl_msg
            else:
                self.cur_stage = stage_data.compl_msg
                stage_next = self.stage_compl + 1
                if stage_next < len(StageData):
                    self.next_action = StageData[stage_next].start_msg
                else:
                    self.next_action = None
            # TODO: should also log this information!!!

        if self.id is None:
            cls = type(self)
            cls.inst = None
        return super().save(*args, **kwargs)

    def start_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the start of the specified stage (and save, by default)
        """
        self.stage_start = stage
        if auto_save:
            self.save()

    def complete_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the completion of the specified stage (and save, by default)
        """
        self.stage_compl = stage
        if auto_save:
            self.save()

    def seeding_done(self) -> bool:
        """Official way to check if seeding is complete (scores validated and final player
        rankings computed)
        """
        return self.stage_compl >= TournStage.SEED_RANKS

    def partner_picks_done(self) -> bool:
        """Official way to check if partner picking is complete (all picks made and teams
        determined)
        """
        return self.stage_compl >= TournStage.TOURN_TEAMS

    def round_robin_done(self) -> bool:
        """Official way to check if round robin is complete (scores validated and final
        team rankings computed)
        """
        return self.stage_compl >= TournStage.TOURN_RANKS

    def playoffs_done(self) -> bool:
        """Official way to check if playoffs (and hence the tournament) is complete
        (scores validated and final team rankings computed)
        """
        return self.stage_compl >= TournStage.FINALS_RANKS
