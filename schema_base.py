# -*- coding: utf-8 -*-

from enum import IntEnum, StrEnum
from typing import ClassVar, Self, NamedTuple
from datetime import datetime, date

from peewee import (Model, DateTimeField, TextField, IntegerField, BooleanField, FloatField,
                    ForeignKeyField, DeferredForeignKey, OperationalError, DoesNotExist, fn)
from playhouse.sqlite_ext import JSONField

from core import log, LogicError
from security import current_user, login_user, logout_user, EuchmgrUser, AuthenticationError
from database import db

#####################
# utility functions #
#####################

TIME_FMT = '%Y-%m-%d %H:%M:%S'

def now_str() -> str:
    """Readable format that works for string comparisons
    """
    return datetime.now().strftime(TIME_FMT)

#############
# BaseModel #
#############

class BaseModel(Model):
    """Base model for this module, with defaults and system columns
    """
    # system columns
    created_at = DateTimeField(default=now_str)
    updated_at = DateTimeField()

    def save(self, *args, **kwargs):
        if not self._dirty:
            return False  # this is what peewee does if no dirty fields
        if not self.updated_at:
            self.updated_at = self.created_at
        elif 'updated_at' not in self._dirty:
            self.updated_at = now_str()
        return super().save(*args, **kwargs)

    class Meta:
        database = db
        legacy_table_names = False
        only_save_dirty = True

######################
# bracket/game stuff #
######################

DFLT_SEED_ROUNDS  = 8
DFLT_TOURN_ROUNDS = 8
DFLT_DIVISIONS    = 2

GAME_PTS          = 10

class Bracket(StrEnum):
    SEED   = 'sd'
    TOURN  = 'rr'  # for "round robin"
    SEMIS  = 'sf'
    FINALS = 'fn'

BRACKET_NAME = {
    Bracket.SEED  : "Seeding",
    Bracket.TOURN : "Round Robin",
    Bracket.SEMIS : "Semifinals",
    Bracket.FINALS: "Finals",
}

##########################
# tournament stage stuff #
##########################

# stage values are chronologically sequenced
TournStage = IntEnum('TournStage',
                     ['TOURN_CREATE',    # 1
                      'PLAYER_ROSTER',
                      'PLAYER_NUMS',
                      'SEED_BRACKET',
                      'SEED_RESULTS',    # 5
                      'SEED_TABULATE',
                      'SEED_RANKS',
                      'PARTNER_PICK',
                      'TOURN_TEAMS',
                      'TEAM_SEEDS',      # 10
                      'TOURN_BRACKET',
                      'TOURN_RESULTS',
                      'TOURN_TABULATE',
                      'TOURN_RANKS',
                      'SEMIS_BRACKET',   # 15
                      'SEMIS_RESULTS',
                      'SEMIS_TABULATE',
                      'SEMIS_RANKS',
                      'FINALS_BRACKET',
                      'FINALS_RESULTS',  # 20
                      'FINALS_TABULATE',
                      'FINALS_RANKS'])

# represents virtual stages before and after TournStage entries
TOURN_INIT = 0
TOURN_FINAL = len(TournStage) + 1
ACTIVE_STAGES = range(TournStage.PLAYER_ROSTER, TOURN_FINAL)

class StageInfo(NamedTuple):
    """Behavior parameters and messages for tournament stages

    REVISIT(?): there is currently redundancy in the two boolean flags, but we may keep it
    this way for integrity checking
    """
    long_running: bool  # possible manual data entry/finalization in order to complete
    auto_advance: bool  # start next stage automatically upon completion
    start_msg:    str   # only needed if long_running
    compl_msg:    str   # not visible if auto_advance (though specified regardless)

# NOTE that we are being a little particular/pedantic about wording for messages here:
# - "seed" means assigned position within a bracket based on past performance
# - "seeding" means the seeding round process
# - "round robin" means the main tournament, not including playoffs
# - "playoffs" means the semi-final and final rounds of the tournament
# - "rank" or "ranking" means finish position after play is over
# - "position" means order on the scale of performance during play
# - "completed" means data entry of an activity (e.g. playing or picking) is done
# - "computed" or "tabulated" means something algorithmically generated by the program
# - "assigned" means the completion of a process that may be either manual or automated
#
STAGE_DATA = [
    StageInfo(False, False, None,                            "New tournament"),
    StageInfo(True,  True,  "Creating player roster",        "Player roster created"),
    StageInfo(True,  False, "Assigning player nums",         "Player nums assigned"),
    StageInfo(False, True,  "Generate seeding bracket",      "Seeding bracket created"),
    StageInfo(True , False, "Seeding round active",          "Seeding results completed"),
    StageInfo(False, False, "Tabulate seeding results",      "Seeding results tabulated"),
    StageInfo(False, True,  None,                            "Seeding rankings computed"),
    StageInfo(True,  False, "Picking partners",              "Partner picks completed"),
    StageInfo(False, False, "Generate round robin brackets", "Round robin teams created"),
    StageInfo(False, False, None,                            "Round robin team seeds computed"),
    StageInfo(False, True,  None,                            "Round robin brackets created"),
    StageInfo(True,  False, "Round robin play active",       "Round robin results completed"),
    StageInfo(False, False, "Tabulate round robin results",  "Round robin results tabulated"),
    StageInfo(False, False, None,                            "Team rankings computed"),
    StageInfo(False, True,  None,                            "Semifinals brackets created"),
    StageInfo(True,  False, "Semifinals play active",        "Semifinals results completed"),
    StageInfo(False, False, "Tabulate semifinals results",   "Semifinals results tabulated"),
    StageInfo(False, False, None,                            "Semifinals rankings computed"),
    StageInfo(False, True,  None,                            "Finals brackets created"),
    StageInfo(True,  False, "Finals play active",            "Finals results completed"),
    StageInfo(False, False, "Tabulate finals results",       "Finals results tabulated"),
    StageInfo(False, False, None,                            "Finals rankings computed")
]

assert len(STAGE_DATA) == len(TournStage)  # not ensured by zip
StageData = dict(zip(TournStage, STAGE_DATA))

#################
# TournInfoBase #
#################

class TournInfoBase(BaseModel):
    """High-level tournament information.  There is only one instance per database (since
    the database encapsulates the entire data for a single tournament).
    """
    name           = TextField(unique=True)
    dates          = TextField(null=True)
    venue          = TextField(null=True)
    stage_start    = IntegerField()
    stage_compl    = IntegerField()
    cur_stage      = TextField()
    next_action    = TextField(null=True)
    players        = IntegerField(null=True)
    teams          = IntegerField(null=True)
    thm_teams      = IntegerField(null=True)
    seed_rounds    = IntegerField(default=DFLT_SEED_ROUNDS)
    tourn_rounds   = IntegerField(default=DFLT_TOURN_ROUNDS)
    divisions      = IntegerField(default=DFLT_DIVISIONS)
    dflt_pw_hash   = TextField(null=True)  # initial/default pw_hash for players

    # class variables
    inst: ClassVar[Self] = None  # singleton instance

    class Meta:
        table_name = 'tourn_info'

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above)
        """
        # see IMPORTANT note in get(), below
        TournInfoBase.inst = None

    @classmethod
    def get(cls, requery: bool = False) -> Self:
        """Return cached singleton instance (purposefully shadows more general base class
        method).
        """
        # IMPORTANT: we have to hardwire the base class name when setting `inst`, so that
        # class variables are not created for subclasses (optional for the reads here, but
        # we definitely want to keep things consistent)!
        if TournInfoBase.inst is None or requery:
            res = [t for t in cls.select().limit(2).iterator()]
            assert len(res) == 1  # fails if not initialized, or unexpected multiple records
            TournInfoBase.inst = res[0]
        return TournInfoBase.inst

    @classmethod
    def mark_stage_start(cls, stage: TournStage) -> None:
        """Mark the start of the specified stage (and save) for the cached singleton
        """
        tourn = cls.get()
        tourn.start_stage(stage)

    @classmethod
    def mark_stage_complete(cls, stage: TournStage) -> None:
        """Mark the completion of the specified stage (and save) for the cached singleton
        """
        tourn = cls.get()
        tourn.complete_stage(stage)

    def save(self, *args, **kwargs):
        """Manage stage changes and associated message text
        """
        if 'stage_compl' in self._dirty:
            stage_data = StageData[self.stage_compl]

            if self.stage_start != self.stage_compl:
                assert not self.stage_start or self.stage_start < self.stage_compl
                # set stage_start implicitly (e.g. for for short operations)
                self.stage_start = self.stage_compl

            if stage_data.auto_advance:
                # this may overwrite the update above, but we leave things like this for
                # the associated integrity checking
                stage_next = self.stage_compl + 1
                self.stage_start = stage_next
                self.cur_stage = StageData[stage_next].start_msg
                self.next_action = StageData[stage_next].compl_msg
            else:
                self.cur_stage = stage_data.compl_msg
                stage_next = self.stage_compl + 1
                if stage_next < len(StageData):
                    self.next_action = StageData[stage_next].start_msg
                else:
                    self.next_action = None
            # TODO: should also log this information!!!

        if self.id is None:
            cls = self.__class__
            cls.clear_cache()
        return super().save(*args, **kwargs)

    def start_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the start of the specified stage (and save, by default)
        """
        self.stage_start = stage
        if auto_save:
            self.save()

    def complete_stage(self, stage: TournStage, auto_save: bool = True) -> None:
        """Mark the completion of the specified stage (and save, by default)
        """
        self.stage_compl = stage
        if auto_save:
            self.save()

    def seeding_done(self) -> bool:
        """Official way to check if seeding is complete (scores validated and final player
        rankings computed)
        """
        return self.stage_compl >= TournStage.SEED_RANKS

    def partner_picks_done(self) -> bool:
        """Official way to check if partner picking is complete (all picks made and teams
        determined)
        """
        return self.stage_compl >= TournStage.TOURN_TEAMS

    def round_robin_done(self) -> bool:
        """Official way to check if round robin is complete (scores validated and final
        team rankings computed)
        """
        return self.stage_compl >= TournStage.TOURN_RANKS

    def playoffs_done(self) -> bool:
        """Official way to check if playoffs (and hence the tournament) is complete
        (scores validated and final team rankings computed)
        """
        return self.stage_compl >= TournStage.FINALS_RANKS

##############
# PlayerBase #
##############

TournInfo = TournInfoBase

class PlayerBase(BaseModel, EuchmgrUser):
    """Represents a player in the tournament, as well as a mobile (i.e. non-admin) user of
    the app.
    """
    # identifying info
    first_name     = TextField()
    last_name      = TextField()
    nick_name      = TextField(unique=True)  # serves as player_name (defaults to last_name)
    reigning_champ = BooleanField(default=False)
    player_num     = IntegerField(unique=True, null=True)  # 1-based, must be contiguous
    pw_hash        = TextField(null=True)    # default pw_hash (in TournInfo) is used, if null
    # seeding round
    seed_wins      = IntegerField(default=0)
    seed_losses    = IntegerField(default=0)
    seed_win_pct   = FloatField(null=True)
    seed_pts_for   = IntegerField(default=0)
    seed_pts_against = IntegerField(default=0)
    seed_pts_pct   = FloatField(null=True)
    player_pos     = IntegerField(null=True)  # based on win_pct, ties possible
    # tie-breaker stuff
    seed_tb_crit   = JSONField(null=True)     # stats criteria used to compute final rank
    seed_tb_data   = JSONField(null=True)     # raw data for reference
    player_rank    = IntegerField(null=True)  # stack-ranked, no ties
    player_rank_adj = IntegerField(null=True) # partner picking determination overrides
    # partner picks
    partner        = ForeignKeyField('self', field='player_num', column_name='partner_num',
                                     null=True)
    partner2       = ForeignKeyField('self', field='player_num', column_name='partner2_num',
                                     null=True)
    picked_by      = ForeignKeyField('self', field='player_num', column_name='picked_by_num',
                                     null=True)
    team           = DeferredForeignKey('Team', null=True)

    # class variables
    player_map: ClassVar[dict[int, Self]] = None  # indexed by player_num

    class Meta:
        table_name = 'player'
        indexes = (
            (('last_name', 'first_name'), True),
        )

    @classmethod
    def clear_cache(cls) -> None:
        """See `clear_schema_cache` (above)
        """
        PlayerBase.player_map = None

    @classmethod
    def get_player_map(cls, requery: bool = False) -> dict[int, Self]:
        """Return dict of all players, indexed by player_num
        """
        tourn = TournInfo.get()
        if tourn.stage_compl < TournStage.PLAYER_NUMS:
            raise LogicError("player_nums not yet assigned")

        if PlayerBase.player_map and not requery:
            return PlayerBase.player_map

        PlayerBase.player_map = {}
        for p in cls.select().iterator():
            PlayerBase.player_map[p.player_num] = p
        return PlayerBase.player_map

    @property
    def name(self) -> str:
        """Alias/shortcut for nick_name (reads only)
        """
        return self.nick_name

    def save(self, *args, **kwargs):
        """Ensure that nick_name is not null, since it is used as the display name in
        brackets (defaults to last_name if not otherwise specified)
        """
        if 'nick_name' in self._dirty:
            if not self.nick_name:
                self.nick_name = self.last_name
        if 'player_num' in self._dirty and self.player_num is not None:
            tourn = TournInfo.get()
            if self.player_num < 1 or self.player_num > tourn.players:
                raise ValueError(f"Player Num must be between 1 and {tourn.players}")
        # cascade commit to partner(s), if dirty
        if self.partner and self.partner._dirty:
            self.partner.save()
            if self.partner2 and self.partner2._dirty:
                self.partner2.save()
        return super().save(*args, **kwargs)

    def login(self, password: str) -> bool:
        """See `EuchmgrUser` (in security.py).

        Also see note about logging of clear password in `AdminUser.login`.
        """
        if password and not isinstance(password, str):
            log.info(f"login denied ({self.name}): invalid pw type {type(password)} "
                     f"('{password}')")
            raise AuthenticationError("Bad password specified")

        tourn = TournInfo.get()
        pw_hash = self.pw_hash or tourn.dflt_pw_hash
        if pw_hash:
            if not check_password_hash(pw_hash, password):
                log.info(f"login failed ({self.name}): bad password ('{password}')")
                raise AuthenticationError("Bad password specified")
        elif password:
            # give no outbound indication that password is not needed
            log.info(f"login failed ({self.name}): bad password ('{password}')")
            raise AuthenticationError("Bad password specified")

        login_user(self)
        log.info(f"login successful ({self.name})")
        return True

    def logout(self) -> bool:
        """See `EuchmgrUser` (in security.py).
        """
        assert current_user == self
        logout_user()
        return True

    def setpass(self, password: str) -> None:
        """See `EuchmgrUser` (in security.py).
        """
        # TODO: enforce password policy (length, diversity, etc.) here!!!
        pw_exists = bool(self.pw_hash)
        self.pw_hash = generate_password_hash(password)
        self.save()
        save = "changed" if pw_exists else "saved"
        log.info(f"password {saved} for user '{self.name}'")
